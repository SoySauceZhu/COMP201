{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":""},{"location":"#welcome-to-software-engineering","title":"Welcome to software engineering","text":"<p>The repository includes lecture notes for <code>COMP201-202425</code>.</p> <p></p>"},{"location":"COMP207/","title":"Database development","text":""},{"location":"COMP207/#sql","title":"SQL","text":""},{"location":"COMP207/#transaction-control","title":"Transaction control","text":""},{"location":"COMP207/#transaction-and-schedule","title":"Transaction and Schedule","text":"<ul> <li> <p>Q1</p> <ol> <li>Note, short hand notation only cares write and read operation, and ignores calculations. So two identical short hand schedule may have different result. </li> </ol> </li> <li> <p>Equivalent Conflict equivalence focus on Order of conflicting operations. Two schedules are conflict-equivalent if:</p> <ul> <li>They involve the same set of transactions.</li> <li>They have the same operations in the same order for conflicting operations (read-write, write-read, write-write on the same data item).</li> </ul> </li> <li> <p>Serializable</p> <ul> <li>Best by represent precedence graph, and find the path</li> <li>2PL guarantees serializable. While normal locks don't.</li> <li>Ex. S: r1(X); w1(X); r2(Y); w3(Z); r3(X); c3; c1; r2(Z); c2;   Is NOT serial. It is not one txn after another</li> </ul> </li> </ul>"},{"location":"COMP207/#acid","title":"ACID","text":"<ol> <li> <p>Q1</p> <ol> <li>Pay attention to \"read\" or \"write\" operation. -- \"check\" or \"update\" </li> <li>By default consider all update operations are reflected to non-volatile memory </li> <li>Durability: Durability consider whether a update that considered as committed (by schedule or by log file) is missing. i.e. If the system commits a transaction but does not actually write the data (or logs) to non-volatile storage, then a power loss or crash could erase the changes. This breaks durability because the transaction\u2019s changes are not permanently saved.  Since in the question all updates (even half-executed) are saved to non-volatile memory (which breaks atomicity), durability is not violated. </li> </ol> </li> <li> <p>What Ensures ACID? </p> </li> <li> <p>Isolation ensures that intermediate states of a transaction are not visible to other transactions. (Serial guarantees isolation)</p> <ul> <li>Locks</li> <li>MVCC</li> </ul> </li> <li> <p>Atomicity ensures that a transaction is all-or-nothing. Either all its operations are completed, or none of them are.</p> <ul> <li>Undo Logging</li> <li>Undo/Redo logging</li> </ul> </li> <li> <p>Durability ensures that once a transaction commits, its changes are permanent, even in the event of a system crash.</p> <ul> <li>Logging</li> <li>Checkpoint</li> <li>Redo logging</li> <li>Un/re logging</li> </ul> </li> </ol>"},{"location":"COMP207/#logging-protocol","title":"Logging protocol","text":"<ol> <li> <p>Q1</p> <ol> <li>Undo/Redo logging -- both D &amp; A </li> <li>Force -- Durability, all committed updates are forces to reflected in non-volatile</li> <li>No Steal -- Atomicity, NO STEAL policy ensures that dirty pages (pages modified by uncommitted transactions aka. half-done updates) are not written to disk before the transaction commits. </li> </ol> </li> <li> <p>Q2</p> <ol> <li>I think he is bullshitting.</li> <li>\u627e\u8865: The file structure is identical, so it is possible to recover a redo log file under undo protocol. </li> </ol> </li> <li> <p>Q3</p> <ol> <li>You can't apply redo or undo protocol on undo/redo log file since the data structure is not compatible. </li> </ol> </li> <li> <p>Q4</p> <ol> <li>The expected starting log index satisfy: (1) CHECKPOINT &amp; END CHECKPOINT both occurs after it (2) It is a Start log or the first line (3) It is the start log of the first uncommitted checking txn </li> </ol> </li> <li> <p>Checkpoint</p> <ol> <li>Can be used to make the size of log file smaller</li> <li>ARIES checkpoint does not necessarily slower than simple checkpoints </li> </ol> </li> </ol>"},{"location":"COMP207/#recoverability-safety","title":"Recoverability (safety)","text":"<p>This part consider about recoverability, focusing on operation to one shared item, and have nothing to do with serializable.</p> Property Key Condition Implication Recoverable (RC) A transaction that has read uncommitted data must commit after the writer commits. Prevents the committed transaction from depending on a later-aborted transaction. Cascadeless (CC) No transaction reads uncommitted data (i.e., reads only committed values aka dirty read). Prevents \u201ccascading\u201d aborts; also implies RC (recoverable). Strict (ST) No transaction reads or writes data written by an uncommitted transaction. Strongest condition; implies CC (and thus RC). Simplifies recovery by avoiding any use of uncommitted data. <ul> <li>Strict 2PL: All exclusive (write) locks are held by a transaction until that transaction commits or aborts.</li> <li>Strict 2PL ensures strict schedule, but basic 2PL doesn't.</li> <li>Strict 2PL doesn't ensure serial. Since 2PL focus on Isolation when two txn touch one item. You can have interleaved txns touching different items</li> <li>Strict &gt;&gt; Cascadeless &gt;&gt; Recoverable</li> <li> <p>Strict &gt;&gt; Serializable, serializable + unlock after commit =&gt; strict</p> </li> <li> <p>Example:</p> <ul> <li>not recoverable: w1(X) r2(X) c2 c1 (c1 might abort, thus T2 is depending on later aborted T1)</li> <li>recoverable: w1(X) w2(X) r2(X) c2 c1. Since what T2 read is previously modified by itself. In other word, T2 doesn't depend on T1</li> <li>cascading: w1(X) r2(X) c1 c2. Aborting T1 should roll back T2 as well since T2 depends on T1</li> <li>cascadeless: w1(X) w2(X) c1 c2.    Aborting T1 will not affect T2, since T2 doesn't depend on T1</li> <li>recoverable but not serializable: w2(X) w1(X) r2(X) c1 c2 (cyclic precedence graph)</li> <li>Serializable but not recoverable: w1(X) r2(X) w2(X) c2 c1 (equivalent to T2 -&gt; T1, X is written by T1)</li> <li>Deadlock can happen in strict schedule. Strict schedule and strict 2PL describe how to ensure isolation. Deadlock describe how to assign two txns to schedule.  i.e. A partial schedule is strict yet has a deadlock.</li> </ul> </li> <li> <p>Question</p> <p>Deadlock May happen in recoverable schedule T1: w1(X) w1(Y) T2: w2(Y) w2(X)  Partial schedule that lead to deadlock: w1(X) w2(Y) __ __ c1 c2 2PL lock schedule also may occur deadlock: w1(X) w2(Y) __ __ In other word, follow (strict-)2PL doesn't mean deadlock-free Prevent deadlock: Timestamp-bases protocols (i.e. wound-wait), time out protocols </p> </li> <li> <p>Additional question</p> <p></p> </li> <li> <p>Question</p> <p>No conflict mean not possible for different txns to read same item, therefore no read dirty page, all strict schedule </p> </li> <li> <p>Question</p> <p>Serializable and strict I think Strict guarantees Serializability, since is you don't read or write uncommitted data, you naturally have all conflict operation pairs in same order. </p> </li> </ul>"},{"location":"COMP207/#timestamp","title":"Timestamp","text":"<ul> <li> <p>Deadlock detection:</p> <ul> <li>Wait-for graph</li> <li>Timestamp based:<ul> <li>Time-out scheme</li> <li>Wait-die scheme (both detect &amp; prevent)</li> <li>Wound-wait scheme (both detect &amp; prevent)</li> </ul> </li> </ul> </li> <li> <p>Timestamp helps Detecting deadlock and let scheduler abort some txn (same timestamp)  This is related to lock and dependencies.</p> <ul> <li>Wait-Die: If older waits for younger, older wait. If younger wait for older, younger roll back and abort (not allowed) (restart with same timestamp).  </li> <li>Wound-Wait: If older wait for younger, older preempts younger txn, younger roll back. If younger wait for older, younger wait. </li> </ul> </li> <li> <p>Timestamp to prevent dead lock (new timestamp) This only cares about timestamp</p> <ul> <li>Prevent (abort and restart) read request of an item if it is written in the future</li> <li>Prevent (abort and restart) write request of an item if it is read or written in the future</li> </ul> </li> <li> <p>Timestamp-based scheduling</p> <ul> <li>Pro:<ul> <li>Enforce conflict-schedule (N.B. 2PL ensure serializability)</li> <li>Prevent deadlock </li> </ul> </li> <li> <p>Con:</p> <ul> <li>Cascading roll backs</li> <li>Starvation may occur (cyclic aborts and restart). Starvation can be prevent.</li> </ul> </li> <li> <p>Timestamp based schedule may not ensure strict schedule.</p> <ul> <li>Additional condition: Delay all read and write requests until the youngest transaction who wrote the item has committed</li> </ul> </li> </ul> </li> <li> <p>Q1: TODO</p> <p> </p> </li> <li> <p>MVCC:</p> <ul> <li>Each txn keeps a copy of dirty page</li> <li>Grant all read request to txns</li> <li>Grand write request only if items is NOT read in the future, otherwise abort and restart</li> <li>There is also a strict variant, where you delay reads until the transaction you read from commits</li> </ul> </li> </ul>"},{"location":"COMP207/#query-processing","title":"Query Processing","text":"<p>Therefore, every relational algebra operation removes duplicates.</p> <p>Q1</p> <p></p>"},{"location":"COMP207/#relational-algebra","title":"Relational Algebra","text":"<ul> <li>selection</li> <li>projection</li> <li>Cartesian product</li> <li>rename</li> <li>Natural Join \\(\\bowtie\\)<ul> <li><code>Select * from R1, R2</code></li> </ul> </li> <li>Equi join \\(\\bowtie_{\\text{ID} = \\text{StudentID}}\\)<ul> <li>Equijoin is a type of join where the condition uses equality (=) between columns from two tables.</li> <li><code>Select * from R1 join R2 on ID = StudentID</code></li> </ul> </li> <li>Semi Join \\(\\ltimes_{\\text{condition}}\\)<ul> <li>A semijoin only includes tuples from the first relation that have matching tuples in the second relation , based on a specified condition</li> </ul> </li> </ul> <p>Selection (natural join (R1,R2)) = Natural join (selection (R1), section (R2))</p>"},{"location":"COMP207/#naive-join","title":"Naive join","text":"<p>Iterate through every line in R1 and find the same values for all common attribute in R2.</p> <p>Running time: \\(O(|R1|*|R2|)\\)</p>"},{"location":"COMP207/#faster-join","title":"Faster Join","text":"<p>Merging</p> <p>Goal: Compute R\u22c8_{A=B}S (no duplicates in join column) Method: Sort R and S, then only iterate once. Running time: \\(O(|R|+|S|+size of output) + O(|R|log|R|)+O(|S|log|S|)\\)</p>"},{"location":"COMP207/#index","title":"Index","text":"<p>Given the value for one or more attributes of the a relation, Provide quick access to tuples with these values.</p> <p>Types:</p> <ul> <li>Primary: A primary index is directly related to the primary key of a table. It is created automatically when a primary key is defined in the table.</li> <li>Secondary: A secondary index is an additional index created on columns that are not part of the primary key. It provides an alternative pathway to retrieve data based on non-primary key attributes.</li> </ul> <p>Hash index are only good for equality while B+ trees are also good for ranges. Greater or Less invoke B+-, equal invoke both hash table and B+-</p> <p></p>"},{"location":"COMP207/#optimizing-query-plan","title":"Optimizing query plan","text":"<p>The key is to rewrite the initial query plan so the intermediate result will be smaller.</p> <ul> <li>Push selection down to the bottom</li> <li>Push projection down to the tree</li> <li>Replace section of a Cartesian product with natural join </li> </ul>"},{"location":"COMP207/#distributed-database","title":"Distributed Database","text":""},{"location":"COMP207/#fragmentation-replication-and-transparency","title":"Fragmentation, replication and transparency","text":"<p>Fragmentation  - Split database into different parts that can be stored at different nodes - Horizontal fragmentation     - Fragment by one or a few attributes (i.e. location), Or other conditions that are easily test - Vertical fragmentation</p> <p>Users don't see fragments, just the full relations.</p> <p>Redundancy improves resilience and efficiency (if you have query on Database that stores exactly what you want)</p> <p>Replication:</p> <ul> <li>Full replication<ul> <li>Each fragment is stored at every site (No fragments)</li> <li>Faster query answering</li> <li>Slow when updates</li> </ul> </li> <li>No replication<ul> <li>Crash is catastrophic</li> </ul> </li> <li>Partial replication</li> </ul> <p>Transparency</p> <p>There were different levels (types?) of transparency</p> <ul> <li>Fragmentation transparency.<ul> <li>Users can access data without knowing whether it is divided (fragmented) across multiple locations.</li> </ul> </li> <li>Replication transparency.<ul> <li>Users are unaware of whether multiple copies (replicas) of data exist.</li> <li>Backup is a copy of data. </li> </ul> </li> <li>Location transparency.<ul> <li>Users or applications can access data without needing to know the physical location of the data</li> </ul> </li> <li>Naming transparency.</li> </ul>"},{"location":"COMP207/#transaction-management-in-distributed-database","title":"Transaction management in distributed database","text":"<p>Voting!</p> <p>Transactions in D-DBMS</p> <p>The central note instructs other note to make transactions. However, If there is a feeling note, Automate will be violated globally.</p> <p>Distributed commit</p> <p>2 phase commit protocol</p> <p>There will be a coordinator. They decide if and will local transaction can commit.</p> <p>Logging is recorded at each node locally. Message sent and retrieved from other nodes are logged too.</p> <p>Rule:</p> <ul> <li>Phase 1: Decide when to commit or abort<ul> <li>The coordinator send a \"PREPARE\" request to all participating nodes.</li> <li>Each note checks if it can commit the transaction and response yes or no.</li> </ul> </li> <li>Phase 2: Commit or abort<ul> <li>If all node vote \"yes\", The coordinator sends a\"COMMIT\" Message and all nodes commit the transaction.</li> <li>If any node votes \"NO\", the coordinator sends an \"ABORT\" message and all node abort</li> </ul> </li> </ul> <p>Logging rule:</p> <p></p> <p></p>"},{"location":"COMP207/#query-in-distributed-database","title":"Query in distributed database","text":"<p>Cost on message transition in high and slow.</p> <p>So we want to transfer as less data as possible</p> <p>Semi join</p> <p>Definition:</p> \\[R\\ltimes S = R \\bowtie (\\pi_{\\text{common attributes}}(S))\\] <p></p> <p>Applicable when \\(|\\pi_\\text{common attributes} (S) + |R\\ltimes S|\\) (S' + R') is smaller that \\(|R|\\) (transfer R directly)</p> <p>Q1</p> <p></p>"},{"location":"COMP207/#semi-structured-data","title":"Semi-structured data","text":""},{"location":"COMP207/#semi-structured-data_1","title":"Semi structured data","text":"<p>Tree-like :</p> <ul> <li>Leaf node: associated with data</li> <li>Inner node: No data associated. Has labelled edges going to other nodes</li> <li>Root: each node reachable from root</li> </ul>"},{"location":"COMP207/#xml","title":"XML","text":"<p>XML forms a tree-like graph, not allow child with multiple parents</p> <p>XML file</p> <ul> <li>Tag (opening &amp; closing)</li> <li>element<ul> <li>i.e. <code>&lt;keyword&gt; arbitrary text &lt;/keyword&gt;</code></li> <li>Elements may be nested, nesting must be proper</li> <li>Root element is contained by no one</li> <li>Case-sensitive</li> <li>May be empty, in short notation: <code>&lt;keyword/&gt;</code></li> </ul> </li> <li>Attributes<ul> <li>Elements can have attributes</li> <li>i.e. <code>&lt;module code='COMP207' title='DBMS'/&gt;</code> -- empty element with 2 attributes</li> <li>You cannot have <code>&lt;module code='COMP207','COMP201' title='DBMS'/&gt;</code> -- only one attribute of a given name</li> <li>When to use attributes or sub-elements:<ul> <li>Staff ID of lecturer (either OK)</li> <li>Email address (not suitable for attr since I have more than one email)</li> </ul> </li> </ul> </li> </ul> <p>Order</p> <p>Elements in an XML document ordered as they occurred in the document</p>"},{"location":"COMP207/#store-xml-in-relational-database","title":"Store XML in relational database","text":"<ul> <li>store XML file as attribute</li> <li>shred XML attributes, then store each (in shredded form)</li> <li>store a schema-independent form<ul> <li>Each row is an attribute, i.e <code>(parent, child, datatype, data)</code></li> </ul> </li> <li>Storing the full XML tree in the database</li> </ul>"},{"location":"COMP207/#dtd-document-type-definition","title":"DTD document type definition","text":"<pre><code>&lt;!ELEMENT bookstore (book+)&gt;\n&lt;!ELEMENT book (title, author, price, year?)&gt;\n&lt;!ELEMENT title (#PCDATA)&gt;\n&lt;!ELEMENT author (#PCDATA)&gt;\n&lt;!ELEMENT price (#PCDATA)&gt;\n&lt;!ELEMENT year (#PCDATA)&gt;\n&lt;!ATTLIST book b_id ID #REQUIRED&gt;\n&lt;!ATTLIST book category (fiction | non-fiction | sci-fi | fantasy) #IMPLIED&gt;\n</code></pre> <p>ELEMENT</p> <ul> <li><code>#PCDATA</code> a symbol for text data</li> <li><code>+</code> one or more</li> <li><code>*</code> any would ok</li> <li>'?' zero or one</li> <li>otherwise appear only once</li> </ul> <p>ATTLIST</p> <ul> <li><code>#IMPLIED</code> optional</li> <li><code>#REQUIRED</code></li> <li><code>#FIXED</code></li> <li>data type<ul> <li><code>CDATA</code>: character data, text</li> <li><code>ID</code>: data type for id. Allows unique key to be associated with an element. i.e. <code>@b_id=\"1\"</code> or <code>@b_id=1</code> both work</li> <li><code>IDREF/IDREFS</code>: reference to a ID attr</li> <li>Enumerated type</li> </ul> </li> </ul> <p>Validating</p> <ul> <li>Well formed: conforms to structural format<ul> <li>Tested by Non-validating processor</li> <li>Only one root</li> <li>Branches and leaves no overlap</li> </ul> </li> <li>Well formed + DTD conformation<ul> <li>Tested by validating processor</li> </ul> </li> </ul> <p>Q1</p> <p></p>"},{"location":"COMP207/#xpath","title":"XPath","text":"<p>XPath allows us to write queries that return a set of values or nodes from an XML document.</p> <p>The result is returned in document order</p> <p></p> <p></p> <ul> <li>Attribute: <code>books/book[@id=1]/@category</code></li> <li>Axis(\"where to find\"): <ul> <li><code>books/child::book/@category</code> is same as omit child axis</li> <li><code>books/book/attribute::category</code> = <code>book/@category</code></li> <li><code>books//title</code> = <code>books/descendant::title</code> find all <code>title</code> elements down from <code>books</code> node. ps. attributes (@) are not element</li> <li><code>ancestor</code></li> <li><code>following-sibling</code></li> <li><code>preceding-sibling</code> NB. Born of the same mother </li> <li><code>parent</code> or <code>..</code></li> <li><code>self</code> or <code>.</code></li> </ul> </li> <li>Conditions:<ul> <li><code>=, &lt;, &gt;, &lt;=, &gt;=, !=, and, or</code></li> <li><code>books/book[@category=\"novel\"]</code></li> <li><code>library/book[title=\"The Invisible Library\"]/@published</code></li> </ul> </li> </ul>"},{"location":"COMP207/#xquery","title":"XQuery","text":"<ul> <li><code>where EVERY $m in $l/teaches satisfies $m/year&lt;2</code></li> <li><code>where SOME $m in $l/teaches satisfies $m/year&lt;2</code></li> <li>Return more than one element <code>return &lt;pair&gt;{$s/name}, {$s/id}&lt;/pair&gt;</code> <code>{variable}</code> substituted variable name with real element </li> </ul> <ul> <li>Ordered By <pre><code>let $doc := doc(\"mydoc.xml\")\nfor $b in $doc/books/book\nfor $author in $b/author\norder by $author descending\nreturn &lt;pair&gt;{$b/title}, {$author}&lt;/pair&gt;\n</code></pre></li> <li>Group BY: <code>avg() count() min() max() sum()</code> <pre><code>let $doc := doc(\"mydoc.xml\")\nfor $m in $doc/university/student/module\ngroup by $mod := $m\nreturn &lt;pair&gt;{$mod}, {count($s)}&lt;/pair&gt;\n</code></pre></li> <li>Distinct value <pre><code>distinct-values(\nlet $doc := doc(\"mydoc.xml\")\nfor $m in $doc/university/student/module\nreturn $m\n)\n</code></pre></li> </ul> <p>Q1</p> <p></p>"},{"location":"COMP207/#nosql","title":"NoSQL","text":"<p>CAP theorem: We cannot achieve at the same time:</p> <ul> <li>COnsistency</li> <li>Availability</li> <li>Partition-tolerance</li> </ul> <p>Approach for noSQL storing</p> <ul> <li>Key-value pair</li> <li>column store</li> <li>document store</li> <li>graph databases</li> </ul>"},{"location":"COMP207/#key-value-pair","title":"Key-value pair","text":"<p>Store key-value pair in distributed way.</p> <p>Replication</p> <p></p>"},{"location":"COMP207/#data-analysis","title":"Data analysis","text":""},{"location":"Lecture10/","title":"System Model","text":""},{"location":"Lecture10/#finite-state-machines","title":"Finite state machines","text":"<p>Finite state machine is a model of computational system consisting of - A set of state - A start state - Input alphabet - Transition function that maps input symbols and current state to next state</p> <p>In a finite state machine (FSM), a state represented by a double circle is a final state (or accepting state). </p> <p>Note</p> <ul> <li>State define behavior and the action of the system</li> <li>State transition a movement from one state to another</li> <li>Rules or conditions (in brackets) must be satisfied to allow a state transition</li> <li>Input event are either external or internal sourced, Which may possibly trigger a certain condition and lead to state transition</li> </ul> <p>Variant of FSM</p> <p>There are many variants  for example</p> <ul> <li>Machines having actions associated with transition (Mealy machine) or state (Moore machine)</li> <li>Multiple Start state</li> <li>Transition conditioned on no input symbol or more than one transition for a given  symbol and state (nondeterministic finite state machine)</li> <li>One or more states designated as acceptable states (recognizer) </li> </ul>"},{"location":"Lecture10/#mealy-and-moore-machine","title":"Mealy and Moore machine","text":"<p>Mealy and Moormachine Our finite state machines with output.</p> <p>Finite state automata are like computers in that they receive input and processed the input by changing states.</p> <p>The owing output that we have seen finite state machines produce is \"yes/no\" or more than that.</p>"},{"location":"Lecture10/#moore-machine","title":"Moore Machine","text":"<p>A Moore machine is just a FSA with two extra attributes:</p> <ul> <li>It has two alphabet, an input and output</li> <li>It has an output letter associated with each state. The machine writes the appropriate letters as it reaches each state </li> </ul>"},{"location":"Lecture10/#mealy-machine","title":"Mealy Machine","text":"<p>Mealy machines are computationally equivalent to more machines. We can implement any Mealy machine using the Moore machine and vice versa.</p> <p>However, in Mealy machine, output is generate by labels on transition. This turn out to be easier to deal with in practice, Making a more practical.</p> <p>The output is in same length as input. It is an output producer, not a language recognizer, so no accept states is in Mealy machine.</p> <p></p>"},{"location":"Lecture10/#petri-net","title":"Petri Net","text":"<p>A petri net is a collection of directed edges connecting places and transitions.</p> <p>Places may have tokens.</p> <p>The state (or marketing) of a net (system) is it assignment of token in places.</p> <p>At any given the moment, several transition might be enable ready to file. Since more than one transaction may be eligible to fire there's no deterministic rule dictating which one must fire at first, The choice is often made arbitrary or based on some external criteria</p> <p>Rule</p> <ul> <li>Arc have capacity one by default</li> <li>Places have infinite capacity by default</li> <li>Transitions have no capacity</li> <li>Arcs can only Connect places to transitions or Transitions to places.</li> </ul> <p></p> <p></p> <p></p> <p></p> <p>Why use Petri NEt</p> <ul> <li>Patron that are non-deterministic and that may be used to model discrete distributed system.<ul> <li>There may be several arcs which can fire and we do not know in which order this will happen.</li> </ul> </li> <li>It's very general, Can be variated to more effectively model wider variety of systems.</li> <li>says patron not have a rigorous and strict mathematical notation. Many crunches about system may be verified based at properties of Petri Net.</li> </ul>"},{"location":"Lecture10/#semantic-data-models","title":"Semantic Data Models","text":"<ul> <li>Used to describe the logical structure of data processed by the system</li> <li>Entity-relation-attribute models</li> <li>Widely used in data design</li> <li>No specific notation provided in the UML, but object and association can be used</li> </ul> <p>Data Dictionary Entities</p> <ul> <li>A data dictionary as a list of all the names used in the system models</li> <li>Descriptions of the entities, relationships and attributes are also included</li> </ul> <p></p>"},{"location":"Lecture10/#object-models","title":"Object Models","text":"<p>Object models describe the system in terms of object classes.</p> <p>It is an abstraction over a set of objects with common attribute and the services provided by each project.</p> <ul> <li>Natural ways of reflecting the real world Entities manipulated by the system</li> <li>More abstract entities are more difficult to model using this app across</li> <li>Object class identification is recognized as a difficult process requiring a deep understanding of the application domain</li> <li>Object classes reflecting domain entities are reusable across systems</li> </ul> <p>Categories</p> <ul> <li>Inheritance models</li> <li>Aggregation models</li> <li>Interaction models</li> </ul>"},{"location":"Lecture10/#uml-unified-modeling-language","title":"UML - Unified Modeling Language","text":"<ul> <li>Devised (designed) by the developers that widely used object oriented analysis and design method</li> <li>Has become effective standard for object oriented modelling</li> <li>There were many types of diagrams:<ul> <li>use case diagram</li> <li>class diagram</li> <li>sequence diagram</li> <li>state chart diagram</li> <li>development diagram</li> </ul> </li> </ul> <p>Note</p> <ul> <li>Object classes are rectangles with name at the top, attribute in the middle section and operations in the bottom section</li> <li>Relations between objects are shown as lines</li> <li>Inheritance is referred to as generalization, which should be upward </li> </ul>"},{"location":"Lecture11/","title":"Modelling Based on Petri Nets","text":""},{"location":"Lecture11/#why-petri-nets","title":"Why petri nets","text":"<ul> <li>Petri Nets can be used to a rigorously defined system</li> <li>They are often used for distributed system (several sub system acting independently) and resource sharing systems</li> <li>Since there are many transitions in patron that activate at the same time, They are nondeterministic</li> </ul>"},{"location":"Lecture11/#classical-petri-net-model","title":"Classical Petri Net Model","text":"<ul> <li>The state of a Petri Net is determined by distribution of tokens over the places</li> <li>A transition in Petri Net can have multiple input and output</li> <li>Enabling condition: A transaction is enabled if each of the input places contains tokens (more than required by weight)</li> <li>Firing: And enabled transition may fire, that consuming tokens from the input and producing tokens for the output places.<ul> <li>Firing is atomic (only one transition fires at a time, Even if more than one is enabled)</li> </ul> </li> <li>A transition without any input can fire at any time</li> <li>A transition without output will consume or delete the incoming tokens</li> <li>Conflict: Two transaction fight for the same token, Even if they were too token in the input place. Who will fire first is nondeterministic. </li> </ul>"},{"location":"Lecture11/#modelling","title":"Modelling","text":"<p>States of a process can be modelled by tokens in places, And transition leading from one state to another modelled by Petri Net transitions.</p> <ul> <li>Tokens can represent resources like human, goods, machines and information  or condition.</li> <li>Places represent buffers, channels, etc.</li> <li>Transition represent events, transformations or transportation.</li> </ul>"},{"location":"Lecture11/#high-level-petri-nets","title":"High-level petri nets","text":"<p>High-level petri nets are extended with - Color - Time - Hierarchy</p>"},{"location":"Lecture12/","title":"Modelling with Petri Net","text":""},{"location":"Lecture12/#arcs-in-petri-nets","title":"Arcs in Petri Nets","text":"<p>The number of arcs (edges) Between two object specifies the number of token to be produced/consumed. Sometimes a number will be written to a single arc.</p> <p>This can be used to model (dis)assembly process.</p> <ul> <li>Current state: The configuration of tokens over the places</li> <li>Reachable state: State reachable from the current state by firing a sequence of enable transitions</li> <li> <p>Deadlock state: State where no transition is enabled</p> </li> <li> <p>Notation: (P1, P2, P3, P4, ...)  </p> </li> <li>Example: </li> </ul>"},{"location":"Lecture12/#high-level-petri-nets","title":"High Level Petri Nets","text":"<p>Classical Petri nets have some modelling problems:</p> <ul> <li>Too large too complex. (you can have sub-nets)</li> <li>Takes too much time to model a given situation</li> <li>Not possible to handle time and data (i.e. Time constraints in traffic light)</li> </ul> <p>Therefore, we have extended it with:</p> <ul> <li>Color: You can identify the tokens by the color. Therefore, color denotes the property associated with each token.</li> <li>Time</li> <li>Hierarchy</li> </ul> <p></p> <p>Extension with Color</p> <p>Each transition has an formal or informal specification that specify:</p> <ul> <li>The number of tokens to be produced</li> <li>The value (property) of these tokens. i.e. the output token equals sum of two inputs</li> <li>Optionally, precondition. The 'if' statement for the output value. </li> </ul> <p>Extension with Time</p> <p>In order to analyst performance, we must model the Duration And delay.</p> <p>The value of time tells us the minimum and maximum time that a transition will take to fire after enabled.</p> <p>This allows us to model performance property of the system.</p> <p></p> <p>Extension with Hierarchy</p> <p>A hierarchy is a mechanism to structure complex Petri Nets compared to data flow diagram.</p> <p>A sub-Net is a net component, including sub places, sub transitions and other subnet.</p> <p>This is the model of abstraction, Can reduce the capacity of the model.</p>"},{"location":"Lecture13/","title":"Software Design","text":"<p>Software design is Deriving a solution which satisfy software requirement.</p>"},{"location":"Lecture13/#design-aspects","title":"Design Aspects","text":"<p>To break up the work, There are some principles:</p> <ul> <li>Each developer must not overlap or duplicate functionalities</li> <li>If one piece of cold writing to databases and another reading<ul> <li>They have to agree on database format, agreed to table names, the condom names and data type</li> <li>One solution is using object database mapping software ORM (i.e. Hibernate)</li> </ul> </li> <li>Interfaces between code should be decided as part of the design process</li> <li>i.e. in Java you can use Interface classes</li> </ul>"},{"location":"Lecture13/#why-software-design","title":"Why Software Design","text":"<ul> <li>Software needs to be<ul> <li>simple</li> <li>understandable</li> <li>flexible</li> <li>portable</li> <li>reusable</li> </ul> </li> <li>Software Is produced by many people Collaborated.</li> </ul> <p>In reality Design and implementation are interleaved.</p>"},{"location":"Lecture13/#stages-of-design","title":"Stages of design","text":"<ul> <li>Problem understanding<ul> <li>looking at the problem from different angles to discover the design requirement</li> </ul> </li> <li>Identify one or more solution<ul> <li>evaluate possible solutions and choose the most appropriate depending on the designers experience and available resources</li> </ul> </li> <li>Describe solution abstractions<ul> <li>Use graphical formal or other descriptive notation is to describe the components of the design</li> </ul> </li> <li>Repeat process for each identified abstraction</li> </ul>"},{"location":"Lecture13/#design-phases","title":"Design Phases","text":"<ul> <li>Architectural design: Determine subsystems</li> <li>Abstract specification: Specify subsystems. i.e. What they should do</li> <li>Interface design: Describe subsystem interfaces. i.e. using XML or JSON for web interfaces</li> <li>Component design: Decompose subsystems into components, Specifically, classes in OOP</li> <li>Data structure design</li> <li>Algorithm design</li> </ul>"},{"location":"Lecture13/#modular-programming","title":"Modular Programming","text":"<p>Computer systems are not Monolithic, They were usually composed of multiple, interactive modules.</p>"},{"location":"Lecture13/#modularity","title":"Modularity","text":"<p>Modularity has long been seen as a key, high-quality software</p> <p>the goal of system design is to decode:</p> <ul> <li>What the modules are</li> <li>What the modules should do?</li> <li>How the modules interact with others.</li> </ul> <p>In the early days, module programming usually refers to 'subroutines'.</p> <p>But modularity cannot bring benefits and unless the modules are:</p> <ul> <li>Autonomous</li> <li>coherent</li> <li>robust</li> </ul>"},{"location":"Lecture13/#procedural-abstraction","title":"Procedural abstraction","text":"<p>The most obvious design method involve functional decomposition.</p> <p>This leads to programs in which procedures represents distinct logical function in a program. This is called procedure abstraction.</p>"},{"location":"Lecture13/#programs-as-functions","title":"Programs as functions","text":"<p>Another view is programs as mathematical function. That is you always have the same output if the input is the same (a mathematical mapping relation), no matter of the state of the system -- referential transparency. </p> <p>Good to utilize for compilers, not good for general purpose information systems.</p> <p>Some programming language directly support this view of programming.</p>"},{"location":"Lecture13/#object-oriented-design","title":"Object oriented design","text":"<ul> <li>The system is viewed as a collaboration of interacting objects.</li> <li>The system state is decentralized and each object manage its own state.</li> <li>Make use of internal state, which against philosophy of functional programming.</li> <li>Objects may be instances of an class and communicating by exchanging messages</li> </ul>"},{"location":"Lecture13/#criteria-for-design-method","title":"Criteria for design method","text":"<ul> <li>Modular decomposability<ul> <li>The criterion satisfied if a method supports decomposition that the problem into small sub problems</li> <li>A top down design method fulfill the criteria.</li> </ul> </li> <li>Modular composability<ul> <li>The criterion is satisfied if a method leads to production of modules that may be recombined to produce new systems. (reusability)</li> </ul> </li> <li>Modular understandability;<ul> <li>A design method satisfies this criteria if it encourages the development of modules which are easily understandable.</li> <li>Can the component be understood on its own?</li> <li>Are meaningful names given?</li> <li>Is the design well documented?</li> <li>Are complex algorithms used?</li> <li>i.e. No ambiguous statement</li> </ul> </li> <li>Modular continuity<ul> <li>A method to satisfy this criteria if it leads to the production of software such as a small changing in the problems specification lead to a small change in modules.</li> </ul> </li> <li>Modular protection <ul> <li>A method should yield system architecture that an abnormal at run-time effects as few modules as possible. </li> </ul> </li> </ul> <p>Top-Down Design</p> <p>In principle, top down design involve starting at the uppermost component in the hierarchy and working down the hierarchy level by level.</p> <p>In practice, larger systems design is never truly top-down. Some branches are designed before others. Designers reuse experience during the design process.</p> <p>Repository models &amp; Direct communication </p> <p>Subsystems making up a system mastic exchange and share data so they can work together effectively</p> <ul> <li>Repository models: All share data is held in a database which may be accessed by all subsystems<ul> <li>advantages include<ul> <li>Databases are an efficient way to share large amount of data on a single data representation and data does not have to be transformed between different subsystems.</li> <li>Subsystems producing data need not be concerned about how their data is used by other subsystems</li> <li>Manage standard operations such as backup, security, access control, recovery and data integrity are centralized and become controlled by the single repository manager.</li> </ul> </li> <li>disadvantages:<ul> <li>Subsystems must agree on the data model which means compromises must be made, for in performers</li> <li>Evolution may be difficult since a large amount of data is generated and translation may be difficult and expensive</li> <li>Different systems have different requirements for security, Recovery and backup policies, which may be difficult to enforce in a single database.</li> <li>It may be difficult to distribute the repository over a number of different machines.</li> </ul> </li> </ul> </li> <li>Direct communication: Each sub system and components maintain their own database. Data is then exchange between subsystems via message passing.</li> </ul>"},{"location":"Lecture14/","title":"Design Methodology","text":""},{"location":"Lecture14/#software-deign","title":"Software Deign","text":"<ul> <li>the design process is to derive a software solution that satisfy requirements. </li> </ul>"},{"location":"Lecture14/#what-is-a-good-system","title":"What is a good system","text":"<ul> <li>Useful and usable</li> <li>Reliable (low coupling)</li> <li>Flexible (low coupled, high cohesion)</li> <li>Affordable (Reusability)</li> <li>Available (dev cost optimized by reusing)</li> </ul>"},{"location":"Lecture14/#module-interface","title":"Module Interface","text":"<ul> <li>abstraction</li> <li>encapsulation: others cannot know the internal info unless interface allows</li> <li>change of internal state of a module doesn't affect other part of the system</li> </ul>"},{"location":"Lecture14/#principles-for-good-design","title":"Principles for good design","text":"<ul> <li>Linguistic Modular Unit<ul> <li>i.e. Java classes. BASIC language is not Linguistic</li> </ul> </li> <li>Few interfaces<ul> <li>Module communicate with as few others as possible. i.e. facade structure</li> </ul> </li> <li>Small interfaces<ul> <li>The interface should concise, aka Loose coupling. Messaging between modules should be minimum</li> <li>The receiver does not change data of sender. i.e. using immutable data (string, ~~array,ptr,etc~~)</li> </ul> </li> <li>Explicit interfaces<ul> <li>The interface and document should be clear. i.e. Who is communicating with who</li> </ul> </li> <li>Information hiding<ul> <li>Make everything private</li> </ul> </li> </ul>"},{"location":"Lecture14/#coupling","title":"Coupling","text":"<ul> <li>loose coupling means changes in a components not affect other components</li> <li>bad practice is 'shared variables/control event'</li> <li>good practice is 'decentralization / store states inside objects instead of shared repo'</li> <li>OOP is loosely coupled. Because no shared state and communication achieved by message passing. However, each object always coupled with its super-class</li> </ul>"},{"location":"Lecture14/#cohesion","title":"Cohesion","text":"<ul> <li>each components only handle one problem logically</li> <li>Inheriting attributes from super-class weakens cohesion</li> <li>various levels:<ul> <li>coincidental Cohesion</li> <li>logical association</li> <li>temporal Cohesion</li> <li>communication Cohesion</li> <li>sequential Cohesion</li> <li>functional Cohesion</li> <li>object cohesion</li> </ul> </li> <li>cohesion &amp; encapsulation:<ul> <li>cohesion: how good the functionality of module is organized logically</li> <li>encapsulation: how good the data and methods are protected</li> </ul> </li> </ul>"},{"location":"Lecture14/#reusability","title":"Reusability","text":"<ul> <li>Reusability ensures low cost of software</li> </ul>"},{"location":"Lecture14/#stepwise-refinement","title":"Stepwise Refinement","text":"<ul> <li>Top-down split problems</li> <li>Recursively refine</li> <li>Until problem can be solved in 7-lines for example</li> </ul>"},{"location":"Lecture14/#good-practice-high-cohesion-loose-coupling-with-good-interface","title":"Good Practice: High Cohesion, Loose Coupling with good interface","text":"<ul> <li>If so, the module is easy to reuse or even pluggable</li> </ul>"},{"location":"Lecture15/","title":"Distributed System Architectures","text":""},{"location":"Lecture15/#software-architectures","title":"Software Architectures","text":"<ul> <li>Architectural Design: <ul> <li>The early stage of design process, generate description of architecture</li> <li>Focuses on sub-systems (System components) and their communication &amp; control</li> <li>In parallel with other specification design</li> </ul> </li> </ul>"},{"location":"Lecture15/#architectural-design-process","title":"Architectural Design process","text":"<ul> <li>System structuring: decompose systems into components and identify the communication</li> <li>Control modelling: determine the model of control relationship between components</li> <li>Modular decomposition: decompose sub-systems into modules</li> </ul>"},{"location":"Lecture15/#sub-systems-and-modules","title":"Sub-systems and Modules","text":"<ul> <li>Sub-system: operation independently, separately. i.e. JAVA packages, login system</li> <li>Modules: in a sub-system, but work together.  </li> </ul>"},{"location":"Lecture15/#benefit-of-subsystem-modelling","title":"Benefit of subsystem modelling","text":"<ul> <li>Re-assemble subsystem to build new system</li> </ul>"},{"location":"Lecture15/#architectural-models","title":"Architectural Models","text":"<ul> <li>Different models may be produce during the design process</li> <li>Different perspective gives different Architectures<ul> <li>Static structural: merely show the components</li> <li>Dynamic process: who is calling how</li> <li>Interface model: define sub-system Interface</li> <li>relationship model: data-flow model</li> </ul> </li> </ul>"},{"location":"Lecture15/#system-structuring","title":"System structuring","text":"<ul> <li>decompose the system into interacting components (sub-systems)</li> <li>use Block Diagram</li> </ul>"},{"location":"Lecture15/#repository-models-data-exchange-between-subsystem","title":"Repository Models: data exchange between subsystem","text":"<ul> <li>central database: suitable for large data</li> <li>internal database: each components pass data to each other</li> </ul>"},{"location":"Lecture15/#client-server-architecture","title":"Client-Server Architecture","text":"<ul> <li>components<ul> <li>servers</li> <li>clients: call on services</li> <li>networks</li> </ul> </li> <li>Feature<ul> <li>distribution of data</li> <li>effective use of networks</li> <li>easy to extend new servers or upgrade</li> <li>No shared data, data interchange inefficient</li> <li>Redundant management in servers</li> <li>Hard to parse server and services</li> </ul> </li> </ul>"},{"location":"Lecture15/#control-model","title":"Control model","text":"<ul> <li>centralized control<ul> <li>one of subsystems control others</li> <li>call-return model</li> <li>top-down subroutines, using in sequential system</li> <li>NB, in a sequential model, events are also handled parallel in background in higher level</li> <li>manager model</li> <li>concurrent system, control subsystems in parallel</li> <li>real-time system control</li> </ul> </li> <li>event-based control: server's handler listening for events then response accordingly <ul> <li>broadcast model</li> <li>integrating different subsystem to response and working together</li> <li>control message is not embedded in event</li> <li>system not know when event happens</li> <li>NB, most of time is idle</li> <li>i.e broadcast -&gt; {LED1, LED2, LED3, LED4}</li> <li>interrupt-driven model</li> <li>NB, most of time is busy</li> <li>used in real time system, fast response</li> <li>there is a handler in each interrupt types. i.e. INTERRUPT A -&gt; LED1, INTERRUPT B -&gt; LED2 </li> </ul> </li> </ul>"},{"location":"Lecture15/#modular-decomposition","title":"Modular decomposition","text":"<ul> <li>object model<ul> <li>loosely coupled objects and well-define interfaces</li> <li>include: classes, attribute, operations</li> </ul> </li> <li>data-flow model<ul> <li>defines the batch sequential pipeline, used in data processing system</li> <li>not suitable for interactive system</li> </ul> </li> </ul>"},{"location":"Lecture16/","title":"Distributed System Architecture","text":""},{"location":"Lecture16/#system-types","title":"System Types","text":"<ul> <li>Personal System</li> <li>Embedded System</li> <li>Distributed System</li> </ul>"},{"location":"Lecture16/#distributed-system-characteristics","title":"Distributed System Characteristics","text":"<ul> <li>Resource Sharing</li> <li>Openness</li> <li>Concurrency</li> <li>Scalability</li> <li>Faulty Tolerance</li> <li>Transparency</li> <li>disadvantages: complex, security, manageability, unpredictability</li> </ul>"},{"location":"Lecture16/#middleware","title":"Middleware","text":"<ul> <li>manage and supports different components of a distributed system</li> <li>usually off-the-shelf  </li> </ul>"},{"location":"Lecture16/#distributed-system-architectures","title":"Distributed System Architectures","text":"<ul> <li>Client-server: Services are called by clients, and server response to the request (sockets)</li> <li>Distributed object architecture: each object can provide to others and use services from others (remote methods)</li> </ul>"},{"location":"Lecture16/#architectural-models","title":"Architectural Models","text":"<ul> <li>Multi-processor<ul> <li>Simplest distributed system model</li> <li>System run task as processes at same time on different processor</li> <li>NB, if there is one physical processor, the OS will slicing the runtime and dispatch to different processes.</li> </ul> </li> <li>Client-server <ul> <li>Applications is modelled as a set of services</li> <li>Client knows of servers and server doesn't know of clients</li> <li>Client and server are logical problem. i.e. run a program listing to request repeatedly</li> <li>processor on server can handle multiple processes. </li> <li>a physical clients terminal can have multiple clients. (sending request by ports)</li> </ul> </li> <li>Distributed object architecture<ul> <li>Each distributed entity is an object that provides and receives services to and from others</li> <li>communication is done by Middleware</li> <li>complex to design</li> <li>pros: </li> <li>Service can be processed and computing on more than one node -- truly distributed</li> <li>Can add more computing resources is needed</li> <li>Flexible and Scalable</li> <li>Dynamically configuration as the objects can migrating across the networks</li> </ul> </li> </ul>"},{"location":"Lecture16/#layered-applications-architecture","title":"Layered Applications Architecture","text":"<p>A modern application usually has 3 layers</p> <ul> <li>Presentation Layer. i.e. GUI</li> <li>Applications processing Layer</li> <li>Data layer. i.e. database</li> </ul>"},{"location":"Lecture16/#thin-and-fat-clients","title":"Thin and Fat clients","text":"<ul> <li>Thin: server handles the application layer and data later</li> <li>Fat: clients handle the application layer, server only send data</li> <li>Nowadays, it is combined. Backend running some security applications, and front end like mobile apps run the thick processing or simply thin UI </li> </ul>"},{"location":"Lecture16/#three-tier-architecture","title":"Three-Tier architecture","text":"<ul> <li>Each layer runs on separate processor. i.e. on more than one server</li> <li>suitable for large scale applications with thousands of clients   </li> </ul>"},{"location":"Lecture17/","title":"Object Oriented Programming","text":""},{"location":"Lecture17/#object-oriented","title":"Object Oriented","text":"<ul> <li>object incorporate both data structure and behavior</li> <li>System functionality is expressed in terms of object services </li> </ul>"},{"location":"Lecture17/#object","title":"Object","text":"<ul> <li>behavior + state + identity<ul> <li>state<ul> <li>state of an object is all the data that it encapsulated</li> <li>objects has a number of attributes</li> <li>some attributes are mutable (address, reference) at the immutable</li> </ul> </li> <li>behavior<ul> <li>an object can understand certain messages, the messages is normally fixed like the set of attribute it has </li> </ul> </li> </ul> </li> <li> <p>identity      -objects are not defined just by the current value of their attributes</p> <ul> <li>the state of an object may change but is still the same object logically </li> </ul> </li> <li> <p>Firstly, don't think water and object will have, instead think what will it do for the system</p> </li> <li>objects are potentially reusable components</li> <li>An object is the thing you can interact with, i.e. You can send your request and get reaction.</li> <li>NB: How object behave may change as the current internal state of the object varies</li> <li>pros: no centralized data, only communicate by messaging. Independent encapsulated easy for maintenance</li> </ul>"},{"location":"Lecture17/#message","title":"message","text":"<ul> <li>a message includes a selector, i.e. the method that returns the message. </li> <li>A message may have arguments </li> </ul>"},{"location":"Lecture17/#interface","title":"interface","text":"<ul> <li>the public interface of a object defines which messages will be accepted</li> <li>an object can also send message to self, this is managed by public or private interface</li> <li>public interface: any part of the system can use</li> <li>private interface: object itself or other privileged components of the system</li> <li>An object can have several interfaces that from different view of point</li> </ul>"},{"location":"Lecture17/#class","title":"Class","text":"<ul> <li>each object is an instance of a class</li> <li>class defines the message understandable as well as how object will response</li> <li>each instance has his own state, but share a same <code>static</code> state of the class</li> <li>A class encapsulates data and behavior, hiding the Implementation details</li> </ul>"},{"location":"Lecture17/#inheritance","title":"Inheritance","text":"<ul> <li>inheritance is the sharing of attributes and operations in the hierarchy relationship</li> <li>subclass(superclass)</li> <li>Object class is always coupled to its superclass</li> </ul>"},{"location":"Lecture17/#polymorphism","title":"Polymorphism","text":"<pre><code>Doctor dc1 = new Surgeon(\"Mingjie\");\nDoctor dc2 = new GeneralPracticer(\"mingjie\");\n\npublic void callDoctor(Doctor dc) {\n  // You can pass dc1 or dc2 as argument in this function\n}\n</code></pre>"},{"location":"Lecture17/#dynamic-binding","title":"Dynamic Binding","text":"<p>The <code>print</code> method is bind dynamically to the subclass in the main method <pre><code>public class Printer {\n  public void print() {\n    System.out.println(\"Printer\");\n  }\n}\n\npublic class LaserPrinter extends Printer{\n  public void print() {\n    System.out.println(\"LaserPrinter\");\n  }\n}\n\npublic static void main(String[] args) {\n  Printer p = new LaserPrinter();\n  p.print(); // ==&gt; \"LaserPrinter\"\n}\n</code></pre></p>"},{"location":"Lecture17/#uml","title":"UML","text":"<ul> <li>UML is a language for specifying, visualizing and documenting</li> </ul>"},{"location":"Lecture18/","title":"Hotel Booking System - case study","text":""},{"location":"Lecture18/#object-oriented-design-and-analysis","title":"Object-Oriented design and analysis","text":"<ul> <li>We should design the following things</li> <li>classes</li> <li>database</li> <li>attributes in of the class and database</li> <li>methods in the class</li> <li>In the design process, start think of candidate classes and then database tables</li> <li>Class persistence is achieved by database table</li> </ul>"},{"location":"Lecture18/#use-case","title":"Use case","text":"<p>Use case of a hotel booking system may include </p>"},{"location":"Lecture18/#noun-analysis","title":"Noun analysis","text":"<ul> <li>Identifying nous in requirement helps to discover class names.</li> <li>Nouns in requirement may lead to classes name or attributes name or nothing.</li> <li>Attributes is inferred from document.</li> </ul>"},{"location":"Lecture18/#oo-analysis","title":"OO analysis","text":"<p>Complete the class diagram: - Includes attributes - Relationship to other classes - Add method according to responsibility</p>"},{"location":"Lecture18/#class-diagram","title":"Class Diagram","text":""},{"location":"Lecture19/","title":"Class Model","text":"<ul> <li>Aggregation</li> <li>Composition</li> <li>Qualified Composition</li> <li>Navigability</li> <li>Derived Association</li> <li>XOR Constraints</li> <li>Association Class: e.g. M to N table in Database</li> </ul>"},{"location":"Lecture2/","title":"Lecture 2","text":""},{"location":"Lecture2/#software-process","title":"Software Process","text":""},{"location":"Lecture2/#software-process_1","title":"Software Process","text":"<ul> <li>Life cycle: the process involves the building of a product. </li> <li>For a software, its life cycle terminates when the provider stops support. </li> </ul>"},{"location":"Lecture2/#software-process-model-development-patter","title":"Software Process Model (Development Patter)","text":""},{"location":"Lecture2/#waterfall-model","title":"Waterfall Model","text":"<ul> <li> <p>A stepwise refinement of requirement.</p> </li> <li> <p>Suitable when the requirement is well-determined and understood.</p> </li> <li> <p>Drawback: </p> <ul> <li>inflexible partitioning of project</li> <li>difficult to update</li> <li>It describes a process of stepwise refinement of the requirement</li> </ul> </li> </ul> <p></p>"},{"location":"Lecture2/#evolutionary-development","title":"Evolutionary Development","text":"<ul> <li>Develop software form a initial implementation, then refine (add new features) it based on user's response.</li> <li> <p>Evolutionary development involves Exploratory development. (Exploratory \\(\\in\\) Evolutionary)</p> <ul> <li>Exploratory development starts with a well-understood requirement</li> <li>The system evolves by adding new features</li> </ul> </li> <li> <p>Drawbacks:</p> <ul> <li>Lack of process visibility</li> <li>Sometimes poorly structured</li> <li>Not suitable in safety critical projects</li> </ul> </li> </ul> <p></p>"},{"location":"Lecture2/#agile-and-scrum","title":"Agile and Scrum","text":"<ul> <li>Lightweight approach to software development</li> <li>Test driven development</li> <li>Pair programming</li> <li>Scrum: Incremental Development<ul> <li>Development and delivery is broken down into increments (sprints) that gives part of the functionality</li> <li>High priority requirement are included in early increments</li> <li>once the development of an increment is started, the requirements are frozen through requirements, so that later increment can continue to evolve.</li> </ul> </li> </ul> <p>Advantage</p> <ul> <li>Customers' value can be delivered with each increment, so system functionality is avaiable earlier.</li> <li>early increments act as a prototype to help elicit requirements for later increment.</li> <li>lower risk of overall project failure</li> <li>the highest priority functions tend to receive more testing.</li> </ul>"},{"location":"Lecture2/#summary","title":"Summary","text":"<ul> <li>iterative process models describe the software process as a cycle of activities</li> <li>generic process models describe the organisation of software processes</li> <li>general activities are: specific specification design and implementation, validation and evolution</li> <li>software process at the activities involved in producing and evolving a software system there were represented in a software process model</li> </ul>"},{"location":"Lecture23/","title":"Verification and Validation","text":""},{"location":"Lecture23/#verification-validation","title":"Verification &amp; Validation","text":"<ul> <li> <p>Verification: \"If the program meets specification documentation\"</p> </li> <li> <p>Validation: \"If the product meets user's expectation\"</p> </li> </ul> <p>Validation &gt; Verification</p>"},{"location":"Lecture23/#in-development-process","title":"In development process","text":"<p>V&amp;V must be applied at each stage in software process - To discovery defects in system - To assess whether system is usable</p>"},{"location":"Lecture23/#static-and-dynamic-verification","title":"Static and Dynamic Verification","text":"<p>Software inspection (static verification): </p> <ul> <li>Looks at the system and code representation to see any problem </li> <li>supplement by tool-bases document and code analysis </li> <li>i.e. Bad variable name, uninitialized value... </li> </ul> <p>Software testing (Dynamic verification): </p> <ul> <li>Concerned with the behavior of system under dynamic operation </li> <li>test by executing the system (test case) with test data to observe functional behavior </li> <li>This is only possible when an executable version of program is available. Which is an advantage of incremental development since a testable version of the system is available at an early stage </li> <li>Real data can be used as test input</li> </ul> <p></p>"},{"location":"Lecture23/#program-testing","title":"Program testing","text":"<ul> <li>Testing can reveal errors' presences BUT CANNOT tell errors' not existence </li> <li>A successful test can find one or more errors only once </li> <li>Nonfunctional requirements can be validated only by program testing </li> <li>Always used program testing with static verification to provide full V&amp;V coverage</li> </ul>"},{"location":"Lecture23/#testing-in-agile","title":"Testing in Agile","text":"<p>Agile development: </p> <ul> <li>Agile Development is test-driven </li> <li>Test cases are developed before coding </li> </ul> <p>Benefits: </p> <ul> <li>Test could be created more validly, since it is based on specification purely </li> <li>All code will be tested </li> <li>Better suits specification</li> </ul>"},{"location":"Lecture23/#types-of-testing","title":"Types of Testing","text":"<p>Defect testing:</p> <ul> <li>Tests are designed to discover system defects</li> <li>A good defect test could reveal the presences of defects in a system</li> </ul> <p>Statistical testing:</p> <ul> <li>Test to reflect the frequency of user inputs</li> <li>Used for reliability estimation</li> </ul>"},{"location":"Lecture23/#vv-goal","title":"V&amp;V Goal","text":"<p>\"Verification and validation should establish a degree of confidence that the software is fit for purpose\"</p> <p>Could not ensure defect-free system</p> <p>The degree of confidence expected is given by:</p> <ul> <li>Software function: How safety-critical the system should be </li> <li>User expectation: Difference users require various level of fitness with specification</li> <li>Marketing environment: Cheaper products may have lower standard of faults </li> </ul>"},{"location":"Lecture23/#testing-and-debugging","title":"Testing and Debugging","text":"<p>Debugging:</p> <ul> <li>Debugging is concerned with locating and repairing errors </li> <li>There is no simple process for debugging. It often involves looking for patterns in defective test output </li> <li>i.e. Syntax error could be caught by compiler and it will indicate the location of error and the type of error. Semantic error may occur in a compiled program but produce incorrect output, they are harder to detect</li> </ul> <p>Testing:</p> <ul> <li>Testing is for find the existence of defects</li> <li>Regression testing: it's advisable to retest the program with all test data after fixed one error to make sure you don't create new problems </li> </ul>"},{"location":"Lecture23/#vv-planning","title":"V&amp;V Planning","text":"<ul> <li>careful planning as required to get the most out of testing and inspection process</li> <li>you should plan when and how to conduct test along the development process</li> <li>ideally,you don't want to submit your untested code to repository </li> </ul>"},{"location":"Lecture23/#structure-of-the-software-test-plan","title":"Structure of the software test plan","text":"<ul> <li>the testing process is a description of the major phase of the testing process</li> <li>requirement traceability: testing should ensure all the requirements are individually tested</li> <li>Tested item: what part of system or functions should be tested </li> <li>testing schedule: an overall schedule for the testing of the software is required and resources must be allocated as part of the general project schedule</li> <li>Test recording: results of tests should be systematically recorded i </li> <li>Hardware requirement: some test should be done on hardware maybe </li> </ul>"},{"location":"Lecture23/#software-inspection","title":"Software inspection","text":"<p>Software inspection check everything from requirement, specification, UML diagram, coding, test data, etc. - Involved people: programmer and another inspector - Inspection is only'looking' for problems. So you can start inspecting before implementation phase </p>"},{"location":"Lecture23/#structural-testing","title":"Structural Testing","text":"<ul> <li>AKA white box testing</li> <li>The objective is to make sure every statement (every line) of code is working correctly</li> </ul>"},{"location":"Lecture23/#path-testing","title":"Path Testing","text":"<ul> <li>Make sure every branch (path) in program is tested and executed at least once</li> <li>Related to program flow diagram</li> <li>Minimum number of test you should do = \"number of edges - number of nodes + 2\" (in a program flow diagram)</li> </ul>"},{"location":"Lecture24/","title":"Software Testing","text":""},{"location":"Lecture24/#testing-process","title":"Testing Process","text":"<ol> <li>Component Testing</li> <li>Developer in responsible</li> <li> <p>Test are derived from developers' experience</p> </li> <li> <p>Integration Testing</p> </li> <li>Independent testing team in responsible</li> <li>Test base on system specification</li> </ol>"},{"location":"Lecture24/#defect-testing","title":"Defect testing","text":"<ul> <li>The goal of defect testing is to discover defects in programs, </li> <li>a successful defect test is a test which causes the problem to behave in an anomalous way. </li> <li>Tests only show the presence but not the absence of defect</li> </ul>"},{"location":"Lecture24/#testing-priorities","title":"Testing priorities","text":"<ul> <li>exhaustive testing is impossible</li> <li>test should exercise a system capabilities rather than components.</li> <li>Testing old capabilities (regression) is more important than testing new capabilities</li> <li>testing typical situations is more important than  boundary value cases</li> </ul>"},{"location":"Lecture24/#test-data-and-test-cases","title":"Test data and test cases","text":"<ul> <li>Test data: Inputs which have been devised to test the system</li> <li>Test case: input as well as the predicted output response of the system </li> </ul>"},{"location":"Lecture24/#black-box-testing","title":"Black box testing","text":"<ul> <li>A black box program is tested based on the system specification</li> <li>Test planning can begin early in the software process </li> </ul>"},{"location":"Lecture24/#equivalence-partitioning","title":"Equivalence partitioning","text":"<ul> <li>Partition out of all test input that generates the same output is called equivalent partition</li> <li>So in order to cover all possible error, you should choose test data from different equivalent partitions</li> </ul>"},{"location":"Lecture25/","title":"Software Testing","text":""},{"location":"Lecture25/#cyclomatic-complexity","title":"Cyclomatic Complexity","text":"<ul> <li>The number of tests to test all control statement is the cyclomatic complexity</li> <li>Cyclomatic complexity = number of edge (any edges) - number of node (any node no matter the type) + 2</li> <li>NB: program flow diagram is directed</li> <li>Dynamic program analyzer can show which path (lines in code) aren't executed</li> </ul>"},{"location":"Lecture25/#independent-path","title":"Independent Path","text":"<p>Independent path is the path that introduce new nodes into test</p>"},{"location":"Lecture25/#integration-testing","title":"Integration testing","text":"<ul> <li>Integration testing is mostly black box, it's not practical to execute every path in a enormous system.</li> <li>It's hard to locating where the error is. You just need to locate which module the error is in.</li> <li>Incremental integration testing reduces this problem</li> </ul>"},{"location":"Lecture25/#incremental-integration-testing","title":"Incremental Integration Testing","text":"<p>Regression testing: future tests also test previous test cases again Test harness: automatically create test data and record the results</p>"},{"location":"Lecture25/#integration-testing-approach","title":"Integration testing approach","text":"<ul> <li>Top-down testing: test general function first<ul> <li>Top-down is good at: Architectural validation, System demonstration, Easy to create tests</li> </ul> </li> <li>bottom-up testing: test sub-system integration first<ul> <li>System that suitable for bottom-up: OOP, real-time system (find which part slows down the whole system), strict performance required system(we can measure the performance of individual parts)</li> </ul> </li> </ul>"},{"location":"Lecture25/#interface-testing","title":"Interface testing","text":"<ul> <li>To detect faults due to interface errors or invalid assumption about interfaces</li> <li>Used when the module will be integrated to make larger systems.</li> <li>Very useful in OOP</li> <li>Good practice: <ul> <li>Design test that the parameters of invoked procedure are at extreme end of range </li> <li>Always test pointer with null pointer</li> <li>Stress testing in message passing system: send a lot of messages at same time</li> <li>In shared memory system, vary the order that components are activated</li> </ul> </li> </ul>"},{"location":"Lecture25/#interface-types","title":"Interface types","text":"<ul> <li>Parameter interfaces</li> <li>Shared memory interfaces: memory addr is shared between procedures</li> <li>Procedural interfaces</li> <li>Message passing interface</li> </ul>"},{"location":"Lecture25/#interface-errors","title":"Interface errors","text":"<ul> <li>Interface misuse: make error in using the interface i.e. wrong arguments</li> <li>Interface misunderstanding: the caller object holds incorrect assumption about the behavior of the called component</li> <li>Timing error: The processing speed of different components is different, so out-of-date information will be accessed</li> </ul>"},{"location":"Lecture25/#stress-testing","title":"Stress testing","text":"<ul> <li>System should fail gracefully when receives too many messages, but not catastrophically</li> <li>System should stop receiving or tell others to stop sending messages before it cannot hold any more</li> <li>Exercise the system beyond its maximum design load</li> <li>Distributed system should aware of it more seriously</li> </ul>"},{"location":"Lecture25/#object-oriented-testing","title":"Object-Oriented Testing","text":"<ul> <li>All methods and functions should have tested to work correctly</li> <li>There is no obvious 'top' to the system for top-down integration and testing</li> </ul>"},{"location":"Lecture25/#testing-levels","title":"Testing levels","text":"<ul> <li>Testing operations related to objects</li> <li>Test object classes</li> <li>Test cluster of cooperating object</li> <li>Test the complete OO system</li> </ul>"},{"location":"Lecture25/#object-class-testing","title":"Object Class Testing","text":"<p>A Complete test coverage of a class involves:  - All associated operations with the objet - Setter and getter  - Exercising the object in all possible states</p> <p>Inheritance makes it more difficult to design object class test since the information may not stored locally</p>"},{"location":"Lecture25/#object-integration","title":"Object integration","text":"<p>You can test your OO program by integrate them up. Clustering testing is for testing a cluster of cooperating objects</p>"},{"location":"Lecture25/#cluster-testing-approach","title":"Cluster testing approach","text":"<ul> <li>Use-case or scenario testing</li> <li>Thread testing: Test the system response as threads through the system. (thread basically means a series of operation)</li> <li>Object interaction testing: Test sequence of object interactions taht stop when an object operation does not call on services from another object</li> </ul>"},{"location":"Lecture26/","title":"Project Management","text":"<p>Organizing, planning and scheduling software project</p>"},{"location":"Lecture26/#software-project-management","title":"Software project management","text":"<p>Concerned with activities involved in ensuring that software is delivered on time and on schedule ending a quarters with the requirement of the organizations developing and procuring the software.</p> <p>Project management is needed because software development is always subject to budget and schedule constraints that are set by the organization developing the software.</p> <p>In terms of software, The product is intangible. Software engineering is not recognized as an engineering discipline with the same status as mechanical electrical engineering, et cetera.</p> <p>Many software projects are one-off project</p>"},{"location":"Lecture26/#management-activities","title":"Management activities","text":"<ul> <li>Proposal writing.</li> <li>Project planning and scheduling..</li> <li>Project costing.</li> <li>Project monitor and review reviews.</li> <li>Personnel selection and evaluation.</li> <li>Report writing and representation.</li> </ul> <p>These activities are not particular to software management. Many techniques of engineering project management are equally applicable to software project management.</p> <p>Technically, complex engineering systems tend to suffer from the same problems as software systems.</p> <p>Project Staffing</p> <p>May not be possible to appoint the ideal people to work on a project</p> <ul> <li>Project budget may not allow for the use of highly paid staff</li> <li>Staff with the appropriate experience may not be available..</li> <li>An organization may wish to develop employee skills on software project. </li> </ul> <p>Managers have to work within these constraints, especially when there is an international shortage of skilled IT staff</p>"},{"location":"Lecture26/#project-planning","title":"Project planning","text":"<p>Probably the most time-consuming project management activities.</p> <p>Continuous activities from initial concept through to system delivery. Plans must be regularly revised as new information becomes available.</p> <p>There is different type of plan may be developed to support the main software project plan that is concerned with schedule on a budget.</p> <ul> <li>Quality plan: Describe the quality procedures and standard that will be used in a project.</li> <li>Validation plan: Describe the approach resources and schedule use for system validation.</li> <li>Configuration management plan: Describe the configuration management procedure and structure to be used. Not about code it self.</li> <li>Maintenance plan: Predict the maintenance requirement of the system, maintenance cost and the effort that needed.</li> <li>Staff development plan: describe how the skills and experience of the project team members will be developed.</li> </ul> <p>A project plan structure:</p> <ul> <li>Introduction.</li> <li>Project organization.</li> <li>Risk analysis.</li> <li>Hardware and software resource requirement.</li> <li>Work breakdown.</li> <li>Project schedule.</li> <li>Monitor and reporting mechanism.</li> <li></li> </ul>"},{"location":"Lecture26/#activity-organization","title":"Activity organization","text":"<ul> <li>Activities in a project should be organized to produce tangible for management to judge process.</li> <li>Milestones at the end point of the process activity.</li> <li>Deliverable a project result deliver to customers.</li> <li>The waterfall process allows for the straightforward definition of progress milestones.</li> </ul>"},{"location":"Lecture26/#project-scheduling","title":"Project scheduling","text":"<ul> <li>split project into tasks and estimate time and resources required to complete each task.</li> <li>Or tasks concurrently to make optimal use of workforce.</li> <li>Minimist task dependencies to avoid delays.</li> <li>Dependent on project managers intuition and experiences.</li> <li></li> </ul> <p>Scheduling problems:</p> <ul> <li>Estimate the difficulty of problems and hence the cost of developing a solution is hard</li> <li>Productivity is not proportional to the number of people working on a task.</li> <li>Adding people to a late project can make it even harder because of communication overhead.</li> <li>The expected always happened. always allow for contingency in planning.</li> </ul> <p>Bar charts and Activity Networks</p> <p>Graphic connotations can be used to illustrate that project schedule</p> <p>Show project breakdown into tasks. Tasks should not be too small, most of them should be taken about a week or two.</p> <p>Activity chart shows task dependencies at the critical path.</p> <p>Bar chart shows schedule against calendar time.</p> <p></p> <p></p> <p></p> <p></p> <p>Pert Chart</p> <p>Tool for analyzing the schedule, including:</p> <ul> <li>Dependencies</li> <li>early start<ul> <li>Earliest time the task can start (Given its dependencies in best case)</li> </ul> </li> <li>early end<ul> <li>Early start time plus estimated task time</li> </ul> </li> <li>last start<ul> <li>Latest time the task can start without delaying the deadline (Consider there may be Tasks depend on this Task)</li> </ul> </li> <li>last end</li> <li>Slack<ul> <li>Amount of tasks can be delayed without delaying the project</li> <li>Slack = 0 is critical</li> </ul> </li> </ul> <p></p>"},{"location":"Lecture26/#risk-management","title":"Risk management","text":"<p>Risk management is concerned with identifying risks and drawing up plans to minimist their effect on the project.</p> <ul> <li>Project risks affect schedule or resources</li> <li>Product risks affect the quality of the performance of the software been development</li> <li>Business risks affect the organization developing or procuring the software.</li> </ul> <p>Risk management process:</p> <ul> <li>Risk identification</li> <li>risk analysis<ul> <li>assess the likelihood (probability) and consequence (seriousness) of the risks</li> <li>i.e. Company financial problem for \u6781\u8d8a\u6c7d\u8f66 is high probability and catastrophic seriousness</li> </ul> </li> <li>risk planning<ul> <li>drawn up plans to avoid or minimist the effect of the risks</li> <li>You should have Avoidance strategy, </li> <li>Minimization strategy (pre design the project so that minimize the effect), </li> <li>Contingency plans (if the risk rises, Contingency plans are plans to deal with that risk)</li> </ul> </li> <li>risk monitoring<ul> <li>Monitor the risks throughout the project</li> </ul> </li> </ul> <p>Types</p> <ul> <li>Technology: The database cannot handle too much transactions</li> <li>People: It is impossible to recruit staff With the skills required perfectly</li> <li>Organizational: The organisation is structured so that different management are responsible for the project. Or the company is in financial problem</li> <li>Tool: Some tools cannot be integrated, Or not efficient enough</li> <li>requirement: Changes to requirement which require A lot of design rework.</li> <li>Estimation: The time required to divide the software is under estimated</li> </ul>"},{"location":"Lecture27/","title":"Cost estimation","text":""},{"location":"Lecture27/#estimate-techniques","title":"Estimate techniques","text":"<p>There is no simple way to make an accurate estimate of the effort required to develop software system.</p> <p>The estimate defines the budget, And the product is adjusted to meet the budget.</p> <ul> <li>Algorithmic code modelling<ul> <li>Based on historical cost information, Generally based on the size of the software</li> </ul> </li> <li>expert judgement</li> <li>One or more experts in both software development and the application domain use their experience to predict software cost process iterate and until some Consensus is reached.</li> <li>Very inaccurate is there is no expert</li> <li>estimation by analogy<ul> <li>by looking at a similar project in the same application domain</li> </ul> </li> <li>Parkinson's law<ul> <li>Parkinson's law states that work expands to fulfil the time available. The cost is determined by available resources rather than by objective statement. In general, \"the project cost whatever resources are available\"</li> <li>disadvantage: System is usually unfinished</li> </ul> </li> <li>Pricing to win<ul> <li>the project cost whatever the customer has to spend on it</li> </ul> </li> </ul>"},{"location":"Lecture3/","title":"Lecture 3 Software Process","text":"<ul> <li>requirement engineering and specification</li> <li>software design</li> <li>programming testing and debugging</li> <li>software evolution</li> </ul>"},{"location":"Lecture3/#software-specification","title":"software specification","text":"<ul> <li>specification is the process of establishing what are required and the constrains of the systems operation and development</li> <li>it may contains:<ul> <li>Feasibility study</li> <li>Requirement elicitation(\u53d1\u6398) and analysis</li> <li>Requirement specification</li> <li>Requirement validation</li> </ul> </li> </ul>"},{"location":"Lecture3/#software-design-and-implementation","title":"software design and implementation","text":"<p>It is the process of converting the system specification into an executable system</p> <ul> <li>Software design  <ul> <li>Design a software structure they Realise the specification</li> <li>Design the database website data structure, communication protocols</li> </ul> </li> <li>Software implementation<ul> <li>Translate this designs into an executable program</li> </ul> </li> <li>N.B. The activities of desire implementation are closely related and may be interleaved</li> </ul>"},{"location":"Lecture3/#design-process-activities","title":"design process activities","text":"<ul> <li>Architectural design<ul> <li>Design the subsystems that makes up the system and their relationships, Well represented by Documentations.</li> </ul> </li> <li>Abstract specifications<ul> <li>For each subsystems, design and specifies the operational constrains and services</li> </ul> </li> <li>Interface design<ul> <li>For each subsystem, clear interface with other other subsystems is designed and well documented</li> </ul> </li> <li>Component design<ul> <li>Allocate services to components, As well as design the interfaces</li> </ul> </li> <li>Data structure design</li> <li>Algorithm Design</li> </ul> <p>Two design philosophy - Data driven design     - Always start by looking at the data that The system will process - Responsibility driven design     - Think of the functions at first (the responsibility of the system)     - break complex functions into smaller function parts     - each responsibilities may require Some data to support the action</p> <p>Design methods - The design is usually documented as a set of graphical models     - Data-flow model     - Entity-relation-attribute     - Structural model     - Object model     - State transition model</p>"},{"location":"Lecture3/#programming-and-debugging","title":"Programming and Debugging","text":"<ul> <li>Programming and debugging process is translating a design into a program and remove Error from the program</li> <li>programming is usually a personal activity</li> <li>programmers carry out some program testing to discover faults in the program and debug in the debugging process</li> </ul> <p>Good programming is iterative</p>"},{"location":"Lecture3/#testing-stage","title":"Testing stage","text":"<ul> <li>Unit testing is for individual components. i.e. Test class methods</li> <li>Module testing is for a collection of Dependent components. i.e. Test classes that are integrated with others</li> <li>Subsystems are integrated by modules, the testing focus on the interfaces of subsystems. i.e. Test a number of classes what collaborate to provide a service, often organized by JAR libs</li> <li>System testing</li> <li>Acceptance testing is for test if the system is acceptable to customer data</li> </ul>"},{"location":"Lecture4/","title":"Software Requirement","text":"<ul> <li>introduced the concept of user and system requirement</li> <li>functional and non-functional require requirement</li> <li>explain two techniques for describing system requirements</li> </ul>"},{"location":"Lecture4/#requirement-engineering","title":"Requirement engineering","text":"<p>requirement engineering is the process of establishing</p> <ul> <li>What is the services that the system should provide?</li> <li>The constraint under which the system operates and is developed.</li> </ul> <p>Why do we need requirements?</p> <ul> <li>Fully understand the problem that need to be solved</li> <li>discover why the problem needs to be solved</li> <li>Determine who should be involved</li> <li>Poorly defined requirements can cause major problems to the projecting both financially and in terms of time</li> </ul>"},{"location":"Lecture4/#what-is-requirement","title":"What is requirement?","text":"<ul> <li>Requirement May be high-level abstraction statement for services or system constraint<ul> <li>Since the specification may be the basis for biding a contract, and should be open to interpretation and update. So it should be high-level and general</li> </ul> </li> <li>Requirement may be detailed mathematical functional specification<ul> <li>Both two statements may be called requirement</li> </ul> </li> <li> <p>Requirement can be refined iteratively</p> </li> <li> <p>Specification focus on services provided</p> </li> <li>Generally Focus of interface and behavior,  instead of what language in programming</li> <li>Specification should be detailed enough to act as a base for testing</li> </ul>"},{"location":"Lecture4/#types-of-requirements","title":"Types of requirements","text":""},{"location":"Lecture4/#levels","title":"Levels","text":"<ul> <li>User requirements. Using natural language and diagrams of services, Sometimes provide the operational constraints. Written for customers to negotiating.</li> <li>System requirements. Structured document setting out detail description of the system services. Written as a contract between client and contractor.</li> <li>Software specification, Describe the software design or implementation. Written for developers<ul> <li>i.e. NLP texts should be defined in UNICODE string. Using hash table to import code efficiency...</li> </ul> </li> </ul> <p>Note</p> <ul> <li>specification focuses on the services provided</li> <li>General do not specify particular language to implement, he started focus on behaviour and the interfaces</li> <li>the specification needs to be detailed enough, because:<ul> <li>it will act as a base for the testing</li> </ul> </li> </ul>"},{"location":"Lecture4/#functional-and-non-functional","title":"Functional and non-functional","text":"<ul> <li>Functional requirement is The statement of services that the system should provide, How the system should react to some impact, And what should be behave in particular situation</li> <li>Non-functional requirement is the constraints on the services or Functions. i.e. Timing, Specific development process, Standards<ul> <li>Define system properties And constraints. i.e. Reliability, Response time, Storage requirement.</li> <li>Process requirement may also be malfunctioning requirements. i.e. The programming language or development method</li> <li>Sometimes no functional requirements may be more critical than functional requirements</li> </ul> </li> <li>Domain requirement<ul> <li>It can be functional or non-functional</li> <li>Requirement related to the application domain. i.e. Medical Institution, Banks</li> <li>Programmers do not often understand Legislative constraints, Therefore, specialist should make the requirement to follow the law</li> </ul> </li> </ul> <p>Non-functional requirements classification</p> <ul> <li>Product requirement.i.e. Execution speed, reliability</li> <li>Organizational requirements. i.e. Coding style, implementation requirements</li> <li>External requirements. i.e. Legislative requirements</li> </ul> <p>Goals or Non-functional requirements </p> <p>Non-functional requirements are difficult to state Precisely and difficult to verify.</p> <p>Yet some can be objectively tested, and you should always make it testable.</p> <p>The goals as to convey the intention of users to the Developers</p> <p>Conflict between non-functional requirements are common</p> <p>i.e. Password should be easy to use &amp; Passwords should have upper/lower case and special symbols</p>"},{"location":"Lecture4/#requirement-imprecision","title":"Requirement Imprecision","text":"<p>Problems arise when requirements are not precisely stated.</p>"},{"location":"Lecture4/#requirement-completeness-and-consistency","title":"Requirement completeness and consistency","text":"<ul> <li>Complete means requirements should include descriptions for all facilities</li> <li>Consistent means requirements should be no conflicts or contradiction in the descriptions of system facilities</li> </ul> <p>Shall for mandatory requirements, Should for desirable requirements</p> <p>Avoid programmer jargon \u60a8\u5c31\u752d\u540a\u574e\u4e86</p>"},{"location":"Lecture4/#requirement-measures","title":"Requirement measures","text":""},{"location":"Lecture5/","title":"Use case analysis","text":""},{"location":"Lecture5/#recap-of-requirement","title":"Recap of requirement","text":"<ul> <li>Requirement can be functional<ul> <li>Defines what the system should do</li> </ul> </li> <li>requirements can be non-functional<ul> <li>Defies the trends are higher the functions are provided.</li> </ul> </li> </ul>"},{"location":"Lecture5/#use-case-and-user-stories","title":"Use case and User stories","text":"<ul> <li> <p>User stories are less formal and simpler to define than use cases, This is widely used in agile Development.</p> </li> <li> <p>Use cases are a scenario based technique in the UML which identify the actors in an interaction, and which describe the interaction itself.</p> <ul> <li>All possible interaction with the system should be involved in use cases</li> <li>Sequence diagram may be used to add details to use cases by showing the sequence of event processing in the system.</li> </ul> </li> </ul>"},{"location":"Lecture5/#use-case","title":"Use case","text":"<ul> <li>Actor<ul> <li>can be human can be non-human</li> </ul> </li> <li>Use case: In a use case diagram, Use case is the task which the actor needs to perform with the help of system</li> </ul> <p>The details of each use case should also be documented by a used case description</p>"},{"location":"Lecture5/#include-and-extend","title":"Include and extend","text":"<ul> <li>Include<ul> <li>Always invoking</li> </ul> </li> <li>Extend<ul> <li>Optional invoking</li> </ul> </li> </ul>"},{"location":"Lecture5/#note","title":"Note","text":"<ul> <li>Use cases do not describe internal behaviors</li> <li>They must describe behaviors with external actors</li> <li>And always involve external behaviors</li> </ul>"},{"location":"Lecture6/","title":"Case study","text":""},{"location":"Lecture7/","title":"Requirement engineering process","text":"<ul> <li>to describe the principal requirements engineering activities and their relationships</li> <li>to introduce takings for requirement elicitation and analysis</li> <li>to describe a requirement validation and a role of requirement reviews</li> <li>to discuss the role of requirement management</li> </ul>"},{"location":"Lecture7/#requirement-engineering-process_1","title":"Requirement engineering process","text":"<ul> <li>Requirement Elicitation<ul> <li>What service do the user requires of the system</li> </ul> </li> <li>Requirement Analysis: <ul> <li>How to classify priorities and negotiate the requirement</li> </ul> </li> <li>Requirement validation<ul> <li>Does the proposed system complete what user requires. i.e. send draft to user </li> </ul> </li> <li>Requirement management<ul> <li>Manage changes to the requirements document</li> </ul> </li> </ul>"},{"location":"Lecture7/#feasibility-studies","title":"Feasibility Studies","text":"<p>Whether the proposed system is worthwhile</p> <ul> <li>If the system contributes to organisational objects</li> <li>If the system can be engineering using current tech technologies and within budget</li> <li>If the system can be integrated with other system that are used currently</li> <li>Is there a simple way of doing so</li> </ul> <p>Feasibility reports </p> <p>A report should include:</p> <ul> <li>Technical feasibility</li> <li>Legal feasibility</li> <li>Economic feasibility</li> <li>Scheduling feasibility</li> </ul>"},{"location":"Lecture7/#elicitation-and-analysis","title":"Elicitation and Analysis","text":"<ul> <li>Aka requirement discovery<ul> <li>Gathering information</li> </ul> </li> <li>Technical staff working with customer to work out:<ul> <li>Application domain</li> <li>Desired service</li> <li>Operational constraints</li> </ul> </li> </ul> <p>Problems</p> <ul> <li>Stakeholder don't know what they really want</li> <li>Stakeholder express requirement in their own term</li> <li>Different stakeholder may have conflict requirements</li> </ul>"},{"location":"Lecture7/#viewpoint","title":"Viewpoint","text":"<p>Viewpoints are the way of structuring the requirements to represent the perspectives of different stakeholders. Stakeholder may be classified at a different viewpoints. This multi-perspective analysis is important as there is no single correct way to analyze system requirements.</p> <p>Viewpoints may be:</p> <ul> <li>Provider and receiver of the system services</li> <li>Regulation as standard</li> <li>Sources of business and non-functional requirements</li> <li>Engineers The responsible to develop and Maintain the system</li> <li>Marketing staff</li> </ul>"},{"location":"Lecture7/#techniques-to-develop-elicitation","title":"Techniques to develop elicitation:","text":"<ul> <li>Prototyping</li> <li>Interviewing</li> <li>Ethnography:<ul> <li>People do not really put forward their requirement, explain or articulate their work.</li> <li>Technical staff only observing and analysis how people actually work.</li> <li>Social and organizational factors of importance may be observed.</li> <li>Ethnographic studies have shown that work is usually richer and more complex than suggested by simple system models.</li> </ul> </li> <li>Focused Ethnography<ul> <li>Combines ethnography with prototyping</li> </ul> </li> </ul>"},{"location":"Lecture7/#security-requirement","title":"Security Requirement","text":"<ul> <li>Confidentiality requirement: Keep data secure<ul> <li>Hard security: Encryption - on data side</li> <li>Soft security: Permission - on IO side</li> <li>Data should be secure in storage, on transition and as long as reasonably possible</li> </ul> </li> <li>Integrity<ul> <li>Check if the data is been modified without notification or authorization</li> <li>i.e. Hash check, CRC check, asymmetric cipher</li> </ul> </li> <li>Authentication &amp; Authorization<ul> <li>authentication for checking who you are</li> <li>authorisation for allowing what you can do</li> </ul> </li> <li>Non-repudiation<ul> <li>repudiation: to refuse what you have compromised</li> <li>Sent message cannot be denied later. Non-regrettable</li> <li>Trusted Broker: acts as a trusted intermediary, relaying messages or transactions between parties while recording proof of the transaction.</li> </ul> </li> <li>Availability (Performance security)<ul> <li>Resilience to power off, flood, damage of server</li> <li>9s: Uptime percentage out of running time. i.e. <code>0.99</code> or <code>99%</code> is 2 nines, \\(365 \\times 24 \\times 0.01 = 87.6\\text{hrs of down time in a year}\\)</li> </ul> </li> </ul>"},{"location":"Lecture8/","title":"Requirement engineering process","text":""},{"location":"Lecture8/#security-requirements","title":"Security requirements","text":"<p>Availability requirement</p> <p></p> <p>9s Terminology not always useful. You may want more than time to describe the availability.</p> <p>Think about three 9s: 78 seconds unavailable per day</p> <p>Ideally you need to specify:</p> <ul> <li>Worst case scenario</li> <li>Worst case delay as well as Downtime</li> <li>How the system can Degrade gracefully (i.e. shutdown with data saved)</li> </ul> <p>Logs and alerts</p> <p>Security depend heavily how the maintain know of activities. Audits and logs help.</p> <ul> <li>Standard log</li> <li>Failed login log</li> <li>Unusual activity log</li> <li>Alert log</li> </ul> <p>Bell-LaPadula model</p> <p>All items are given a security clearance level</p> <ul> <li>Top secret, Secret, sensitive, unclassified</li> </ul> <p>Rules:</p> <ul> <li>No read up:<ul> <li>A subject cannot read the document above their clearance level.</li> </ul> </li> <li>No write down:<ul> <li>A document cannot be copied/included in another document that in a lower security clearance.</li> <li>So if I want to add a top-secret term to a \"sensitive\" Document, The result will be a top-secret document</li> </ul> </li> <li>Only trusted subjects can write document down<ul> <li>The subject should be shown really trust worth Regarding to the security policy.</li> </ul> </li> </ul> <p>Security Specifying</p> <ul> <li>Ideally, security requirement should be kept as open as possible to allow further upgrading if encryption algorithm or protocols</li> </ul> <p>Security policy</p> <p>Make requirement for people to follow.</p> <ul> <li>Shredding documents after reading</li> <li>Security disposal of USB device</li> </ul>"},{"location":"Lecture8/#requirement-checking","title":"Requirement Checking","text":"<ul> <li>Validity: does the system provide the functions which support the customers need?</li> <li>Consistency: Are there any requirement conflicts?</li> <li>Completeness: Are all functions included?</li> <li>Realism: Can the requirement be implemented whether they given available budget and technology?</li> <li>Variability: can the requirement be checked?</li> </ul> <p>Test cases within Scenarios</p> <ul> <li>Show the developer by examples, what will happen given certain condition.</li> <li>They can be used to create testing for the software</li> <li>Scenario test making things very clear and reduce ambiguity</li> </ul> <p>Agile Requirement Tool</p> <ul> <li> <p>Cucumber: A user story tool</p> <ul> <li>It's a software tool used to help writ requirements which are linked directly to tests</li> <li>Cucumber uses a text format Gherkin which describe features and test data, can be integrated with JUnit </li> </ul> </li> <li> <p>Gives simple and clear notation to write specification</p> </li> <li>Analysts/test team and even customers can learn Gherkin and develop feature files</li> <li>Step files are produced by development team</li> <li>Test data can be change easily</li> </ul>"},{"location":"Lecture9/","title":"System models","text":"<ul> <li>behavioural model (FSM, Petri-Net)</li> <li>Data model</li> <li>Object modelling (UML)</li> </ul>"},{"location":"Lecture9/#system-modelling","title":"System modelling","text":"<p>Use our requirements must be written in such a way that non-technical experts can understand them (natural language)\u3002</p> <p>However, some detailed system requirement may be expressed in a more technique way. One of the most widely used technique is to document the system specification by system models.</p> <p>System model is a graphical representation that described business process and the system.</p> <p>System modelling helps the Analyst to understand the functionality of the system and models are used to communicate with customers</p> <p>Different models Present the system from different perspective</p> <ul> <li>External perspective</li> <li>Behavioral perspective</li> <li>Structural perspective: Show the architecture of system or data</li> </ul> <p>System Model Advantages</p> <ul> <li>They can be easier to understand using a Verbose natural language description</li> <li>Can leave out unnecessary details of the system, Therefore, focus on what is important</li> <li>Different models can focus on different approaches to abstraction</li> </ul> <p>Weakness</p> <ul> <li>System model do not show non-functional requirement</li> <li>They don't include information about whether a methods is appropriate for a given problem</li> <li>May produce too much documentation</li> <li>System models are sometimes too detailed and difficult for users to understand</li> </ul>"},{"location":"Lecture9/#model-types","title":"Model Types","text":"<ul> <li>Data processing model: Show how data is processed under different stages</li> <li>Composition model: Show how entities are composed with the others</li> <li>Architectural model: Show subsystems</li> <li>Classification model: Show how many have common characteristics. i.e. class diagram</li> <li>Stimulus/response model: Show how the system React to event</li> <li>Context model: Used to illustrate the boundaries of the system<ul> <li>The boundary depends on social and organizational concern</li> <li>The architecture of the system</li> </ul> </li> </ul>"},{"location":"Lecture9/#behavioral-model","title":"Behavioral model","text":"<p>Two types of behavioral model to describe the overall behavior of a system. Both of them are required for a description of the systems behavior</p> <ul> <li>Data processing model<ul> <li>i.e. Data flow diagram</li> <li>Date of floor diagram track and document how the data associated with the process. It can also show how the data exchange between the system and others.</li> <li>Developing a deep flow diagram is usually a top-down process</li> <li>DFD shows a func tional perspective, instead of data perspective (that shows how data is represented and structured). It show how data is manipulated. </li> </ul> </li> <li>State machine model<ul> <li>State chart diagram or State machine models Shows the behaviour of the system in response to external and internal events</li> <li>Often used in real time system</li> <li>State chart are an integral part of UML </li> <li>Stay hard also allow the decomposition of the model into sub models. Can be complemented by tables describing the states and the stimuli <ul> <li>The label on an arc denote the event (or the function method)</li> <li>A guard is used to ensure system move only if expression is satisfied (condition)</li> <li>A state can have a composite state in it (sub diagram)</li> </ul> </li> <li>Tips:<ul> <li>Always have one idle state where the process is not active</li> <li>All states need some exit (no deadlock)</li> <li>Use multiple stage charts to keep one design simple</li> <li>system can be described by multiple state machine running concurrently</li> </ul> </li> </ul> </li> </ul> <p>Finite State Machine</p> <p>A finite state machine is a model of computation consisting of</p> <ul> <li>A set of state</li> <li>A start state</li> <li>Input alphabet</li> <li>A transaction function that maps input symbols and current state into a next state</li> </ul>"},{"location":"note/","title":"Lecture Note","text":""},{"location":"note/#lecture-14-design-methodology","title":"Lecture 14 Design Methodology","text":""},{"location":"note/#software-deign","title":"Software Deign","text":"<ul> <li>the design process is to derive a software solution that satisfy requirements. </li> </ul>"},{"location":"note/#what-is-a-good-system","title":"What is a good system","text":"<ul> <li>Useful and usable</li> <li>Reliable (low coupling)</li> <li>Flexible (low coupled, high cohesion)</li> <li>Affordable (Reusability)</li> <li>Available (dev cost optimized by reusing)</li> </ul>"},{"location":"note/#module-interface","title":"Module Interface","text":"<ul> <li>abstraction</li> <li>encapsulation: others cannot know the internal info unless interface allows</li> <li>change of internal state of a module doesn't affect other part of the system</li> </ul>"},{"location":"note/#principles-for-good-design","title":"Principles for good design","text":"<ul> <li>Linguistic Modular Unit<ul> <li>i.e. Java classes. BASIC language is not Linguistic</li> </ul> </li> <li>Few interfaces<ul> <li>Module communicate with as few others as possible. i.e. facade structure</li> </ul> </li> <li>Small interfaces<ul> <li>The interface should concise, aka Loose coupling. Messaging between modules should be minimum</li> <li>The receiver does not change data of sender. i.e. using immutable data (string, ~~array,ptr,etc~~)</li> </ul> </li> <li>Explicit interfaces<ul> <li>The interface and document should be clear. i.e. Who is communicating with who</li> </ul> </li> <li>Information hiding<ul> <li>Make everything private</li> </ul> </li> </ul>"},{"location":"note/#coupling","title":"Coupling","text":"<ul> <li>loose coupling means changes in a components not affect other components</li> <li>bad practice is 'shared variables/control event'</li> <li>good practice is 'decentralization / store states inside objects instead of shared repo'</li> <li>OOP is loosely coupled. Because no shared state and communication achieved by message passing. However, each object always coupled with its super-class</li> </ul>"},{"location":"note/#cohesion","title":"Cohesion","text":"<ul> <li>each components only handle one problem logically</li> <li>Inheriting attributes from super-class weakens cohesion</li> <li>various levels:<ul> <li>coincidental Cohesion</li> <li>logical association</li> <li>temporal Cohesion</li> <li>communication Cohesion</li> <li>sequential Cohesion</li> <li>functional Cohesion</li> <li>object cohesion</li> </ul> </li> <li>cohesion &amp; encapsulation:<ul> <li>cohesion: how good the functionality of module is organized logically</li> <li>encapsulation: how good the data and methods are protected</li> </ul> </li> </ul>"},{"location":"note/#reusability","title":"Reusability","text":"<ul> <li>Reusability ensures low cost of software</li> </ul>"},{"location":"note/#stepwise-refinement","title":"Stepwise Refinement","text":"<ul> <li>Top-down split problems</li> <li>Recursively refine</li> <li>Until problem can be solved in 7-lines for example</li> </ul>"},{"location":"note/#good-practice-high-cohesion-loose-coupling-with-good-interface","title":"Good Practice: High Cohesion, Loose Coupling with good interface","text":"<ul> <li>If so, the module is easy to reuse or even pluggable</li> </ul>"},{"location":"note/#lecture-15-distributed-system-architectures","title":"Lecture 15 Distributed System Architectures","text":""},{"location":"note/#software-architectures","title":"Software Architectures","text":"<ul> <li>Architectural Design: <ul> <li>The early stage of design process, generate description of architecture</li> <li>Focuses on sub-systems (System components) and their communication &amp; control</li> <li>In parallel with other specification design</li> </ul> </li> </ul>"},{"location":"note/#architectural-design-process","title":"Architectural Design process","text":"<ul> <li>System structuring: decompose systems into components and identify the communication</li> <li>Control modelling: determine the model of control relationship between components</li> <li>Modular decomposition: decompose sub-systems into modules</li> </ul>"},{"location":"note/#sub-systems-and-modules","title":"Sub-systems and Modules","text":"<ul> <li>Sub-system: operation independently, separately. i.e. JAVA packages, login system</li> <li>Modules: in a sub-system, but work together.  </li> </ul>"},{"location":"note/#benefit-of-subsystem-modelling","title":"Benefit of subsystem modelling","text":"<ul> <li>Re-assemble subsystem to build new system</li> </ul>"},{"location":"note/#architectural-models","title":"Architectural Models","text":"<ul> <li>Different models may be produce during the design process</li> <li>Different perspective gives different Architectures<ul> <li>Static structural: merely show the components</li> <li>Dynamic process: who is calling how</li> <li>Interface model: define sub-system Interface</li> <li>relationship model: data-flow model</li> </ul> </li> </ul>"},{"location":"note/#system-structuring","title":"System structuring","text":"<ul> <li>decompose the system into interacting components (sub-systems)</li> <li>use Block Diagram</li> </ul>"},{"location":"note/#repository-models-data-exchange-between-subsystem","title":"Repository Models: data exchange between subsystem","text":"<ul> <li>central database: suitable for large data</li> <li>internal database: each components pass data to each other</li> </ul>"},{"location":"note/#client-server-architecture","title":"Client-Server Architecture","text":"<ul> <li>components<ul> <li>servers</li> <li>clients: call on services</li> <li>networks</li> </ul> </li> <li>Feature<ul> <li>distribution of data</li> <li>effective use of networks</li> <li>easy to extend new servers or upgrade</li> <li>No shared data, data interchange inefficient</li> <li>Redundant management in servers</li> <li>Hard to parse server and services</li> </ul> </li> </ul>"},{"location":"note/#control-model","title":"Control model","text":"<ul> <li>centralized control<ul> <li>one of subsystems control others</li> <li>call-return model</li> <li>top-down subroutines, using in sequential system</li> <li>NB, in a sequential model, events are also handled parallel in background in higher level</li> <li>manager model</li> <li>concurrent system, control subsystems in parallel</li> <li>real-time system control</li> </ul> </li> <li>event-based control: server's handler listening for events then response accordingly <ul> <li>broadcast model</li> <li>integrating different subsystem to response and working together</li> <li>control message is not embedded in event</li> <li>system not know when event happens</li> <li>NB, most of time is idle</li> <li>i.e broadcast -&gt; {LED1, LED2, LED3, LED4}</li> <li>interrupt-driven model</li> <li>NB, most of time is busy</li> <li>used in real time system, fast response</li> <li>there is a handler in each interrupt types. i.e. INTERRUPT A -&gt; LED1, INTERRUPT B -&gt; LED2 </li> </ul> </li> </ul>"},{"location":"note/#modular-decomposition","title":"Modular decomposition","text":"<ul> <li>object model<ul> <li>loosely coupled objects and well-define interfaces</li> <li>include: classes, attribute, operations</li> </ul> </li> <li>data-flow model<ul> <li>defines the batch sequential pipeline, used in data processing system</li> <li>not suitable for interactive system</li> </ul> </li> </ul>"},{"location":"note/#lecture-16-distributed-system-architecture","title":"Lecture 16 Distributed System Architecture","text":""},{"location":"note/#system-types","title":"System Types","text":"<ul> <li>Personal System</li> <li>Embedded System</li> <li>Distributed System</li> </ul>"},{"location":"note/#distributed-system-characteristics","title":"Distributed System Characteristics","text":"<ul> <li>Resource Sharing</li> <li>Openness</li> <li>Concurrency</li> <li>Scalability</li> <li>Faulty Tolerance</li> <li>Transparency</li> <li>disadvantages: complex, security, manageability, unpredictability</li> </ul>"},{"location":"note/#middleware","title":"Middleware","text":"<ul> <li>manage and supports different components of a distributed system</li> <li>usually off-the-shelf  </li> </ul>"},{"location":"note/#distributed-system-architectures","title":"Distributed System Architectures","text":"<ul> <li>Client-server: Services are called by clients, and server response to the request (sockets)</li> <li>Distributed object architecture: each object can provide to others and use services from others (remote methods)</li> </ul>"},{"location":"note/#architectural-models_1","title":"Architectural Models","text":"<ul> <li>Multi-processor<ul> <li>Simplest distributed system model</li> <li>System run task as processes at same time on different processor</li> <li>NB, if there is one physical processor, the OS will slicing the runtime and dispatch to different processes.</li> </ul> </li> <li>Client-server <ul> <li>Applications is modelled as a set of services</li> <li>Client knows of servers and server doesn't know of clients</li> <li>Client and server are logical problem. i.e. run a program listing to request repeatedly</li> <li>processor on server can handle multiple processes. </li> <li>a physical clients terminal can have multiple clients. (sending request by ports)</li> </ul> </li> <li>Distributed object architecture<ul> <li>Each distributed entity is an object that provides and receives services to and from others</li> <li>communication is done by Middleware</li> <li>complex to design</li> <li>pros: </li> <li>Service can be processed and computing on more than one node -- truly distributed</li> <li>Can add more computing resources is needed</li> <li>Flexible and Scalable</li> <li>Dynamically configuration as the objects can migrating across the networks</li> </ul> </li> </ul>"},{"location":"note/#layered-applications-architecture","title":"Layered Applications Architecture","text":"<ul> <li>Presentation Layer</li> <li>Applications processing Layer</li> <li>data layer</li> </ul>"},{"location":"note/#thin-and-fat-clients","title":"Thin and Fat clients","text":"<ul> <li>Thin: server handles the application layer and data later</li> <li>Fat: clients handle the application layer, server only send data</li> <li>Nowadays, it is combined. Backend running some security applications, and front end like mobile apps run the thick processing or simply thin UI </li> </ul>"},{"location":"note/#three-tier-architecture","title":"Three-Tier architecture","text":"<ul> <li>Each layer runs on separate processor. i.e. on more than one server</li> <li>suitable for large scale applications with thousands of clients   </li> </ul>"},{"location":"note/#lecture-17-oop","title":"Lecture 17 OOP","text":""},{"location":"note/#object-oriented","title":"Object Oriented","text":"<ul> <li>object incorporate both data structure and behavior</li> <li>System functionality is expressed in terms of object services </li> </ul>"},{"location":"note/#object","title":"Object","text":"<ul> <li> <p>behavior + state + identity</p> <ul> <li>state</li> <li>state of an object is all the data that it encapsulated</li> <li>objects has a number of attributes</li> <li>some attributes are mutable (address, reference) at the immutable</li> <li>behavior</li> <li>an object can understand certain messages, the messages is normally fixed like the set of attribute it has </li> <li>identity    -objects are not defined just by the current value of their attributes</li> <li>the state of an object may change but is still the same object logically </li> </ul> </li> <li> <p>Firstly, don't think water and object will have, instead think what will it do for the system</p> </li> <li>objects are potentially reusable components</li> <li>An object is the thing you can interact with, i.e. You can send your request and get reaction.</li> <li>NB: How object behave may change as the current internal state of the object varies</li> <li>pros: no centralized data, only communicate by messaging. Independent encapsulated easy for maintenance</li> </ul>"},{"location":"note/#message","title":"message","text":"<ul> <li>a message includes a selector, i.e. the method that returns the message. </li> <li>A message may have arguments </li> </ul>"},{"location":"note/#interface","title":"interface","text":"<ul> <li>the public interface of a object defines which messages will be accepted</li> <li>an object can also send message to self, this is managed by public or private interface</li> <li>public interface: any part of the system can use</li> <li>private interface: object itself or other privileged components of the system</li> <li>An object can have several interfaces that from different view of point</li> </ul>"},{"location":"note/#class","title":"Class","text":"<ul> <li>each object is an instance of a class</li> <li>class defines the message understandable as well as how object will response</li> <li>each instance has his own state, but share a same <code>static</code> state of the class</li> <li>A class encapsulates data and behavior, hiding the Implementation details</li> </ul>"},{"location":"note/#inheritance","title":"Inheritance","text":"<ul> <li>inheritance is the sharing of attributes and operations in the hierarchy relationship</li> <li>subclass(superclass)</li> <li>Object class is always coupled to its superclass</li> </ul>"},{"location":"note/#polymorphism","title":"Polymorphism","text":"<pre><code>Doctor dc1 = new Surgeon(\"Mingjie\");\nDoctor dc2 = new GeneralPracticer(\"mingjie\");\n\npublic void callDoctor(Doctor dc) {\n  // You can pass dc1 or dc2 in this function\n}\n</code></pre>"},{"location":"note/#dynamic-binding","title":"Dynamic Binding","text":"<p>The <code>print</code> method is bind dynamically to the subclass in the main method <pre><code>public class Printer {\n  public void print() {\n    System.out.println(\"Printer\");\n  }\n}\n\npublic class LaserPrinter extends Printer{\n  public void print() {\n    System.out.println(\"LaserPrinter\");\n  }\n}\n\npublic static void main(String[] args) {\n  Printer p = new LaserPrinter();\n  p.print(); // ==&gt; \"LaserPrinter\"\n}\n</code></pre></p>"},{"location":"note/#uml","title":"UML","text":"<ul> <li>UML is a language for specifying, visualizing and documenting</li> </ul>"},{"location":"note/#lecture-18-hotel-booking-system-case-study","title":"Lecture 18 Hotel Booking System - case study","text":""},{"location":"note/#object-oriented-design-and-analysis","title":"Object-Oriented design and analysis","text":"<ul> <li>We should design the following things</li> <li>classes</li> <li>database</li> <li>attributes in of the class and database</li> <li>methods in the class</li> <li>In the design process, start think of candidate classes and then database tables</li> <li>Class persistence is achieved by database table</li> </ul>"},{"location":"note/#use-case","title":"Use case","text":"<p>Use case of a hotel booking system may include </p>"},{"location":"note/#noun-analysis","title":"Noun analysis","text":"<ul> <li>Identifying nous in requirement helps to discover class names.</li> <li>Nouns in requirement may lead to classes name or attributes name or nothing.</li> <li>Attributes is inferred from document.</li> </ul>"},{"location":"note/#oo-analysis","title":"OO analysis","text":"<p>Complete the class diagram: - Includes attributes - Relationship to other classes - Add method according to responsibility</p>"},{"location":"note/#class-diagram","title":"Class Diagram","text":""},{"location":"note/#lecture-2-software-process","title":"Lecture 2 Software Process","text":""},{"location":"note/#software-process","title":"Software Process","text":"<ul> <li>Life cycle: the process involves the building of a product. </li> <li>For a software, its life cycle terminates when the provider stops support. </li> </ul>"},{"location":"note/#software-process-model-development-patter","title":"Software Process Model (Development Patter)","text":""},{"location":"note/#waterfall-model","title":"Waterfall Model","text":"<ul> <li> <p>A stepwise refinement of requirement.</p> </li> <li> <p>Suitable when the requirement is well-determined and understood.</p> </li> <li> <p>Drawback: </p> <ul> <li>inflexible partitioning of project</li> <li>difficult to update</li> </ul> </li> </ul> <p></p>"},{"location":"note/#evolutionary-development","title":"Evolutionary Development","text":"<ul> <li>Starting with a well-understood requirement</li> <li>Develop software form a initial implementation, then refine (add new features) it based on user's response.</li> <li> <p>Evolutionary development involves Exploratory development</p> </li> <li> <p>Drawbacks:</p> <ul> <li>Lack of process visibility</li> <li>Sometimes poorly structured</li> <li>Not suitable in safety critical projects</li> </ul> </li> </ul> <p></p>"},{"location":"note/#agile-and-scrum","title":"Agile and Scrum","text":"<ul> <li>Lightweight approach to software development</li> <li>Scrum: Incremental Development<ul> <li>Development and delivery is broken down into increments (sprints) that gives part of the functionality</li> <li>High priority requirement are included in early increments</li> </ul> </li> </ul>"}]}